<!DOCTYPE html><html lang="ko-kr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<meta name="dcterms.date" content="2017-11-10">
<meta name="dcterms.rights" content="© Copyright IBM Corp. 2014, 2017">

<meta name="description" content="앱 또는 서비스를 개발할 때 간단한 테스트를 실행하는 경우 또는 고가용성이 필요하지 않은 단기 프로세스에는 단일 컨테이너를 사용하십시오. 사용자 자신의 네트워킹 프론트 엔드를 사용하려면 컨테이너에 공인 IP 주소를 지정할 수 있습니다.">
<meta name="keywords" content="단일 컨테이너, 대시보드, GUI, IBM Containers, 컨테이너, CLI, docker run, bx ic, run, 업데이트, 명령행, 링크, --link, IP 주소, 공용, ip-bind, ip-request, ips, ip-unbind, 제거, 릴리스, docker rm, rm, 튜토리얼, 시작하기, cli, 설치, 플러그인, 이미지, 배치, docker compose, 다중 컨테이너 배치, 다중 컨테이너 앱, docker-compose.yml, 스케일링, 로드 밸런서, nginx, 워크로드, yml, 지원되는 옵션, faq">
<meta name="geo.country" content="ZZ">
<script>
    digitalData = {
      page: {
        pageInfo: {
  language: "ko-kr",

  version: "v18",
  ibm: {
  country: "ZZ",
  type: "CT701"
  
         }
       }
     }
   };
  </script><link rel="stylesheet" type="text/css" href="./ibmdita.css">
<title>IBM Bluemix Container Service에서 단일 컨테이너로 단기 태스크 실행</title>
</head>
<body><main role="main"><div><article class="nested0" role="article" aria-labelledby="d75728e6" id="container_single_ui"><h1 class="topictitle1" id="d75728e6">단일 컨테이너로 단기 태스크 실행</h1>
<div class="abstract"><div class="shortdesc"><span class="ph">앱 또는 서비스를 개발할 때 간단한 테스트를 실행하는 경우 또는 고가용성이
필요하지 않은 단기 프로세스에는 단일 컨테이너를 사용하십시오. 사용자 자신의 네트워킹 프론트 엔드를 사용하려면 컨테이너에 공인 IP 주소를
지정할 수 있습니다.</span></div>


<div class="p"><div class="note attention"><span class="attentiontitle">주의:</span> <span class="ph"><span class="ph">단일 및 확장 가능 컨테이너</span>의 무료 평가판은 사용할 수 없습니다. 
<a href="cs_ov.html" title="IBM Bluemix Container Service는 Kubernetes API를 사용하여 독립적인 컴퓨팅 호스트의 클러스터에서 컨테이너화된 앱의 배치, 오퍼레이션, 스케일링 및 모니터링을 자동화하는 강력한 도구, 직관적인 사용자 경험, 기본 제공 보안 및 격리를 제공할 수 있도록 Docker 및 Kubernetes를 결합합니다.">클러스터 관리에 대해 알아보고
<span class="keyword">Bluemix®</span> 퍼블릭에서
<span class="keyword">IBM®
Bluemix Container Service</span>의 Kubernetes로 마이그레이션하십시오. </a></span></div>
</div>


<div class="p">이 페이지의
내용:<div class="lines">&nbsp;&nbsp;&nbsp;&nbsp; • <a href="container_single_ui.html#gui" title="Bluemix GUI에서 컨테이너를 작성하고 배치합니다.">GUI</a> 또는 <a href="container_single_ui.html#container_single_cli" title="run 명령을 사용하여 컨테이너를 작성합니다. 컨테이너는 그 안에 이미지를 포함해야 합니다. 아직 이미지가 없으면 조직의 개인용 이미지 레지스트리에서 기본적으로 사용할 수 있는 기본 IBM 인증 이미지 중 하나를 사용할 수 있습니다.">CLI</a>에서 단일 컨테이너로 단기 서비스 실행<br>
&nbsp;&nbsp;&nbsp;&nbsp; • <a href="container_single_ui.html#container_single_updating" title="앱을 업데이트하려면 새 컨테이너를 배치해야 합니다. 새 이미지를 푸시하는 경우 컨테이너는 자동으로 다시 시작되지 않습니다.">컨테이너 업데이트</a><br>
&nbsp;&nbsp;&nbsp;&nbsp; • <a href="container_single_ui.html#container_linking" title="컨테이너가 동일한 영역의 다른 컨테이너에 링크되는 경우, IBM Bluemix Container Service는 소스 컨테이너의 수신 컨테이너에 호스트 항목을 작성합니다. 자주 변경될 수 있는 특정 IP 주소 대신에 별명을 사용하여 소스 컨테이너를 참조할 수 있습니다.">컨테이너 연결</a><br>
&nbsp;&nbsp;&nbsp;&nbsp; • <a href="container_single_ui.html#container_cli_ips" title="공인 IP 주소를 요청하고 Bluemix의 컨테이너에 바인드합니다.">IP 주소 요청 및 바인딩</a><br>
&nbsp;&nbsp;&nbsp;&nbsp; • <a href="container_single_ui.html#container_single_remove" title="할당량의 사용을 최대화하려면 사용하지 않는 컨테이너를 가끔씩 제거하십시오.">단일 컨테이너 제거</a><br>
&nbsp;&nbsp;&nbsp;&nbsp; • 튜토리얼: <a href="container_single_ui.html#container_gettingstarted_tutorial" title="IBM Bluemix는 퍼블릭 클라우드에서 Docker 컨테이너를 실행하는 기능을 제공합니다. 컨테이너를 사용하여 호스트 운영 체제와 독립적으로 실행되는 자체 포함, 보안 웹 앱을 배치하십시오. 컨테이너가 동일한 시스템 커널을 사용하기 때문에 컨테이너는 경량이고 많은 시스템 리소스를 필요로 하지 않고, 따라서 가상 머신보다 더욱 효율적으로 실행될 수 있습니다. 이 튜토리얼얼은 Bluemix에서 Docker 컨테이너를 사용하여 메시징 웹 앱을 빌드하는 방법을 소개합니다. 프로세스에서 Dockerfile을 쓰고 Docker 이미지를 개인용 Bluemix 이미지 레지스트리에 추가하며 컨테이너를 함께 연결합니다.">단일 컨테이너 웹 애플리케이션 작성</a><br>
&nbsp;&nbsp;&nbsp;&nbsp; • 튜토리얼: <a href="container_single_ui.html#container_compose_intro" title="데이터베이스, 서비스 및 캐시 등의 다중 컴포넌트가 있는 앱의 경우에는 모든 컨테이너를 함께 시작하고 종료하도록 조정하는 것이 어려울 수 있습니다. 이 튜토리얼에서는 하나의 Docker Compose 명령을 사용하여 마이크로서비스 아키텍처에서 다중 컨테이너 배치로 앱을 배치 및 실행하는 방법을 알아봅니다. 이 시스템의 일부인 각 컨테이너는 Docker Compose 서비스 정의를 기반으로 하며 자체 격리된 환경에서 실행됩니다.">다중 컨테이너 배치 작성</a></div>
</div>
</div>
<aside role="complementary" aria-labelledby="d75728e6"></aside><article class="topic task nested1" role="article" aria-labelledby="d75728e170" id="gui"><h2 class="topictitle2" id="d75728e170"><span class="keyword">Bluemix</span> GUI에서 단일 컨테이너로 단기 태스크 실행</h2>
<div class="body taskbody"><p class="shortdesc"><span class="keyword">Bluemix</span> GUI에서 컨테이너를 작성하고 배치합니다. </p>
<div class="section prereq" id="gui__prereq_oh5_421_4z"><div class="p">시작하기 전에 다음 정보를 고려하십시오. <ul id="gui__ul_ph5_421_4z"><li id="gui__role"><span class="keyword">Bluemix</span> 영역에서 컨테이너를 작성하려면 이 영역에 대해 개발자 역할이 있어야 합니다.
각 역할의 권한 및
역할 편집 방법에 대한 자세한 정보는 <span class="ph"><a href="../iam/users_roles.html">사용자 및 역할</a></span>의 내용을 참조하십시오.</li>
<li id="gui__add_image"><span class="keyword">Bluemix</span>
GUI에서 IBM 제공 공용 이미지 또는 조직의 개인용 <span class="keyword">Bluemix</span>
레지스트리에 있는 기존 이미지로부터 컨테이너를 작성합니다. <span class="keyword wintitle">카탈로그</span>에 이미지를 추가하는 것에 대한
자세한 정보는 <a href="container_images_adding_ov.html#container_images_adding_ov" title="컨테이너 이미지는 작성하는 모든 컨테이너의 기초가 됩니다. 이미지는 빌드 아티팩트(예: 앱, 앱의 구성 및 이의 종속 항목) 및 이미지를 빌드하는 지시사항이 포함된 파일인 Dockerfile에서 작성됩니다. 컨테이너 이미지를 실행 파일(.exe 또는 .bin)로서 생각하십시오. 실행 가능 앱 파일을 실행하는 즉시 앱의 인스턴스가 작성됩니다. 컨테이너를 실행하면 이미지에서 컨테이너 인스턴스가 작성됩니다.">조직의 개인용 Bluemix 이미지 레지스트리에 Docker 이미지 추가</a>의 내용을 참조하십시오.</li>
<li id="gui__existing_ip">IP 주소를 새로 작성하는 대신 사용할 수 있는 영역의 기존 IP 주소가 있는지 여부를 확인하십시오.
자세한 정보는
<a href="container_single_ui.html#container_cli_ips_list" title="단일 컨테이너가 인터넷에서 액세스 가능하도록 하려면 단일 컨테이너에 공인 IP 주소를 바인드해야 합니다. IP 주소를 요청하기 전에, 조직에 이미 지정된 공인 IP 주소의 목록을 검토하고 이러한 기존 IP 주소 중 하나를 사용할 수 있는지를 확인하십시오.">명령행 인터페이스(CLI)를 사용하여 조직에 대한 기존 공인 IP 주소 찾기</a>의 내용을 참조하십시오.</li>
<li id="gui__bind_service"><span class="keyword">Bluemix</span> 서비스를 컨테이너에 바인드하고자 함을 아는 경우에는
<span class="keyword">Bluemix</span> 서비스를 영역에 추가하십시오. 자세한 정보는
<a href="container_integrations.html#container_integrations_binding" title="IBM Bluemix에는 서비스 목록이 있으며 앱 개발자 대신 해당 서비스를 관리합니다. 사용할 컨테이너의 Bluemix 서비스를 추가하려면 이 서비스의 인스턴스를 요청하고 서비스를 컨테이너에 바인드해야 합니다.">Bluemix GUI에서 서비스 바인딩</a>의 내용을 참조하십시오.</li>
<li>컨테이너에서 파일에 대한 액세스를 허용하는 공유 디스크를 원하는 경우에는
컨테이너를 작성하기 전에 볼륨을 작성하십시오. 자세한 정보는
<a href="container_volumes_ov.html#container_volumes_cli" title="볼륨은 앱이 작성하는 데이터 또는 앱이 실행해야 하는 파일의 지속적 스토리지 위치입니다. 명령행에서 컨테이너의 볼륨을 작성할 수 있습니다.">명령행(CLI)에서 볼륨 작성</a>의 내용을 참조하십시오.</li>
</ul>
</div>
</div><p class="li stepsection">이미지로 컨테이너를 작성하고 배치하려면 다음을 수행하십시오. </p><ol class="steps" id="gui__steps_qh5_421_4z"><li class="step stepexpand" id="gui__start"><span class="cmd"><span class="ph" data-hd-otherprops="registry_check">카탈로그에서 <span class="ph uicontrol">컨테이너</span>를 선택하고 이미지를 선택하십시오. </span></span> 개인용 <span class="keyword">Bluemix</span> 레지스트리에 저장된 이미지와 IBM이 제공한 이미지가 모두 표시됩니다. </li>
<li class="step stepexpand" id="gui__namespace"><span class="cmd">조직에 대해 네임스페이스가 이미 설정되면, 새로 작성하도록 프롬프트가 표시되지 않으며 다음 단계를 계속할 수 있습니다. </span> 아직 조직에 대해 네임스페이스가 지정되지 않은 경우, 이미지 레지스트리에 대해 네임스페이스를 구성하기 위한 프롬프트가 표시됩니다. 네임스페이스는 <span class="keyword">Bluemix</span>에서 개인용 레지스트리를 식별하는 고유 이름입니다. 네임스페이스는 조직에 대해 한 번 지정되며 작성된 후에는 변경할 수 없습니다.여러 <span class="keyword">Bluemix</span> 지역에서 <span class="keyword">IBM
Bluemix Container Service</span>를 사용하려면
각 지역의 네임스페이스를 설정해야 합니다. <div class="note tip" id="gui__namespace_naming"><span class="tiptitle">팁:</span> 네임스페이스에 대한 다음 규칙을 준수하십시오.
<ul id="gui__ul_rh5_421_4z"><li>소문자, 숫자, 밑줄(_)만 포함할 수 있습니다.</li>
<li>길이는 4 - 30자까지 가능합니다. 명령행에서 컨테이너를 관리할 계획이면 빨리 입력할 수 있는 짧은 네임스페이스 이름을 선호할 것입니다.</li>
<li>해당 이름은 <span class="keyword">Bluemix</span>에서 고유해야 합니다. </li>
</ul>
</div>
</li>
<li class="step stepexpand"><span class="cmd">그리고 컨테이너 정의를 시작하십시오. </span> 기본적으로 창은 <span class="ph uicontrol">단일</span> 컨테이너 탭으로 열립니다. </li>
<li class="step stepexpand" id="gui__tag">옵션: <span class="cmd">이미지 이름 아래에서 사용할 이미지의 태그 또는 버전을 선택하십시오.</span></li>
<li class="step stepexpand" id="gui__space"><span class="cmd">사용자 조직의 <span class="keyword">Bluemix</span> 영역 중 하나를 선택하십시오. </span></li>
<li class="step stepexpand"><span class="cmd"><span class="ph uicontrol">컨테이너 이름</span> 필드에 컨테이너의 이름을 입력하십시오. </span> <div class="note tip"><span class="tiptitle">팁:</span> 컨테이너 이름은 문자로 시작해야 하며 대문자, 소문자, 숫자, 마침표(.), 밑줄(_)
또는 하이픈(-)을 포함할 수 있습니다.</div>
</li>
<li class="step stepexpand" id="gui__size"><span class="cmd"><span class="ph uicontrol">크기</span> 필드에서 컨테이너 크기를 선택하십시오.</span> 기본 크기는 <span class="ph uicontrol" data-hd-audience="yellow">Micro (256MB 메모리, 16GB 스토리지)</span>입니다. 선택하는 크기에 따라
런타임 중에 컨테이너가 컴퓨팅 호스트에서 얻는 메모리와 디스크 공간의 크기가 달라지며,
컨테이너를 작성한 후에는 변경할 수 없습니다. 기타 사용 가능한 크기는 다음과 같습니다.
<ul data-hd-audience="yellow" id="gui__ul_sh5_421_4z"><li>Pico(64MB 메모리, 4GB 디스크 공간)</li>
<li>Nano(128 MB 메모리, 8GB 디스크 공간)</li>
<li>Tiny(512MB 메모리, 32GB 디스크 공간)</li>
<li>Small(1GB 메모리, 64GB 디스크 공간)</li>
<li>Medium(2GB 메모리, 128GB 디스크 공간)</li>
<li>Large(4GB 메모리, 256GB 디스크 공간)</li>
<li>X-Large(8GB 메모리, 512GB 디스크 공간)</li>
<li>2X-Large(16GB 메모리, 1TB 디스크 공간)</li>
</ul>

</li>
<li class="step stepexpand"><span class="cmd"><span class="ph uicontrol">공인 IP 주소</span> 필드에서 새 공인 IP 주소를 요청 및 지정할 것인지 여부를 선택하십시오.</span> 공인 IP 주소를 사용하면 컨테이너와 공용으로 연결할 수 있습니다. 공인 IP 주소를 원하지 않는 한 가지 예는 사설 네트워크 내부에서만 사용자의 앱에 표시되는 데이터베이스를 사용하고 있는 경우입니다.
<div class="steps note"><span class="notetitle">참고:</span> 공인 IP 주소 바인딩은 단일 컨테이너로(부터) 전송되는 데이터를 암호화하는 SSL 인증서를 포함하지 않습니다.앱에서 SSL 암호화를 요구하는 경우 자체 SSL 솔루션을 구현하거나 단일 컨테이너 대신 컨테이너 그룹을 사용할 수 있습니다. 컨테이너 그룹은 이미 SSL 인증서를 포함하는 공용 라우트에 바인드되므로 추가 구성 없이 HTTPS로 컨테이너 그룹에 액세스할 수 있습니다. 자세한 정보는 <a href="container_ha.html#container_group_ui" title="Bluemix GUI에서 확장 가능한 그룹 컨테이너를 작성하고 배치합니다. 컨테이너 그룹에는 동일한 이미지를 실행하는 두 개 이상의 컨테이너가 포함됩니다. 확장성 및 신뢰성이 요구되는 워크로드가 포함된 장기적 서비스를 실행하거나 필요한 스케일로 테스트할 때 컨테이너 그룹을 사용하십시오.">Bluemix GUI로 컨테이너 그룹 작성</a>을 참조하십시오. </div>

<p>사용할 수 있는 IP 주소가 있는 경우 <span class="ph uicontrol">지정되지 않은 채로 두기</span>를
선택하고 컨테이너가 작성된 후 컨테이너에 IP 주소를 바인드하십시오.</p>
</li>
<li class="step stepexpand"><span class="cmd"><span class="ph uicontrol">공용 포트</span> 필드에서 공개할 공용 포트를 지정하십시오. </span> 이미지가 빌드될 때 이미지에 대해 Dockerfile에 지정된 포트로 필드가 채워져있습니다.
공용 포트를 지정할 때는 사용하려는 IP 프로토콜을 표시하기 위해 UDP와 TCP 사이에서 선택할 수 있습니다. 프로토콜을 지정하지 않으면
포트가 자동으로 TCP 트래픽에 대해 노출됩니다. 공용 포트를 노출할 때 노출된 포트에서만 공개 데이터를 전송 및 수신할 수 있게 하는 컨테이너에 대한 공용 네트워크 보안 그룹을 작성합니다. 기타 공용 포트는 닫히고 인터넷에서 앱에 액세스하는 데 사용할 수 없습니다. 쉼표(,)로 각 포트를 분리하여 다중 포트를 포함할 수 있습니다.  <div class="p" id="gui__ports_p">사용 중인 이미지의 Dockerfile에 포트가 지정된 경우 해당 포트를 포함하십시오.<div class="note tip"><span class="tiptitle">팁:</span> <ul id="gui__ul_uh5_421_4z"><li>IBM 인증 Liberty Server 이미지 또는 이 이미지의 수정된 버전에 대해서는 포트 <kbd class="ph userinput">9080</kbd>을 입력하십시오.</li>
<li>IBM 인증 Node.js 이미지 또는 이 이미지의 수정된 버전에 대해서는
임의의 포트(예: <kbd class="ph userinput">8000</kbd>)를 입력하십시오. </li>
</ul>
</div>
</div>
</li>
<li class="step stepexpand">옵션: <span class="cmd">볼륨 추가, 환경 변수의 추가 또는 <span class="keyword">Bluemix</span>
서비스의 바인드를 수행하려면 <span class="ph uicontrol">고급 옵션</span>을 펼치십시오. </span></li>
<li class="step stepexpand" id="gui__volume">옵션: <span class="cmd">데이터 또는 파일 스토리지를 정의하십시오. 기존 볼륨을 컨테이너 또는 컨테이너 그룹과 연관시키십시오. </span> 볼륨은 컨테이너 내에서 파일에 액세스할 수 있도록 허용하는 공유 디스크입니다.
컨테이너의 경로는 볼륨이 마운트되는 컨테이너의 파일 시스템을 표시합니다.
<div class="note restriction"><span class="restrictiontitle">제한사항:</span> 명령행을 사용하는 방법으로만 <span class="keyword">Bluemix</span> 영역에서 볼륨을 삭제할 수 있습니다. </div>
<ol type="a" class="ol substeps" id="gui__substeps_vh5_421_4z"><li class="li substep"><span class="cmd"><span class="ph uicontrol">기본 볼륨 지정</span>을 클릭하십시오.</span></li>
<li class="li substep"><span class="cmd">드롭 다운 목록에서 볼륨을 선택하십시오.</span></li>
<li class="li substep"><span class="cmd">다음 필드에서 볼륨을 맵핑할 컨테이너의 경로를 지정하십시오. </span> 예를 들어, <span class="ph filepath">/var/lib/my_volume</span>입니다. </li>
<li class="li substep"><span class="cmd">볼륨을 읽기 전용으로 지정하려면 <span class="ph uicontrol">읽기 전용</span>을 선택하십시오.</span> 기본적으로 볼륨은 읽기/쓰기입니다.</li>
<li class="li substep"><span class="cmd">볼륨을 여러 개 추가하려면 <span class="ph uicontrol">기존 볼륨 지정</span>을 클릭하고
이 단계를 반복하십시오. </span></li>
</ol>
</li>
<li class="step stepexpand" id="gui__env_var">옵션: <span class="cmd">환경 변수를 정의하십시오. </span> <ol type="a" class="ol substeps" id="gui__substeps_wh5_421_4z"><li class="li substep substepexpand"><span class="cmd"><span class="ph uicontrol">새 환경 변수 추가</span>를 클릭하십시오. </span></li>
<li class="li substep substepexpand"><span class="cmd">환경 변수의 이름을 입력하십시오. </span></li>
<li class="li substep substepexpand"><span class="cmd">그다음 필드에 환경 변수의 값을 지정하십시오.</span></li>
<li class="li substep substepexpand"><span class="cmd">환경 변수를 여러 개 추가하려면 <span class="ph uicontrol">새 환경 변수 추가</span>를 클릭하고 이 단계를 반복하십시오. </span> <div class="tablenoborder"><table summary="" id="gui__env_keys_group" class="defaultstyle"><caption><span class="tablecap">표 1. 제안된 환경 변수</span></caption><thead><tr><th id="d75728e503" class="thleft">환경 변수</th>
<th id="d75728e505" class="thleft">설명</th>
</tr>
</thead>
<tbody><tr><td headers="d75728e503 "><div class="lines"><samp class="ph codeph">CCS_BIND_APP=</samp><br>
<samp class="ph codeph"><var class="keyword varname">&lt;appname&gt;</var></samp></div>
</td>
<td headers="d75728e505 ">일부 <span class="keyword">Bluemix</span> 서비스는 컨테이너에 대한 직접 바인딩을 지원하지 않습니다. 
이 경우에는 Cloud Foundry 앱을 작성하고 <span class="keyword">Bluemix</span> 서비스를
이에 바인드해야 합니다. 그리고 <samp class="ph codeph">CCS_BIND_APP</samp>를 사용하여 앱을 컨테이너에 바인드하십시오. 
Cloud Foundry 앱은 브릿지 역할을 하며, <span class="keyword">Bluemix</span>에서
브릿지 앱의 VCAP_SERVICES 정보를 실행 중인 컨테이너 인스턴스에 삽입할 수 있도록 허용합니다. </td>
</tr>
<tr><td headers="d75728e503 "><div class="lines"><samp class="ph codeph">CCS_BIND_SRV=</samp><br>
<samp class="ph codeph"><var class="keyword varname">&lt;service_instance_name1&gt;,</var></samp><br>
<samp class="ph codeph"><var class="keyword varname">&lt;service_instance_name2&gt;</var></samp></div>

<div class="steps note"><span class="notetitle">참고:</span>  서비스가 <samp class="ph codeph">CCS_BIND_SRV=</samp> 환경 변수 사용을 지원하지 않는 경우에는
<samp class="ph codeph">CCS_BIND_APP=</samp>를 대신 사용하십시오. </div>
</td>
<td headers="d75728e505 ">브릿지 앱을 사용하지 않고 <span class="keyword">Bluemix</span> 서비스를
컨테이너에 직접 바인드하려면 <samp class="ph codeph">CCS_BIND_SRV</samp>를 사용하십시오. 이 바인딩을 사용하면
<span class="keyword">Bluemix</span>에서 VCAP_SERVICES 정보를
실행 중인 컨테이너 인스턴스에 삽입할 수 있습니다. 다수의 <span class="keyword">Bluemix</span>
서비스를 나열하려면 동일한 환경 변수의 일부로서 이를 포함하십시오. </td>
</tr>
<tr><td headers="d75728e503 "><div class="lines">(더 이상 사용되지 않음) <samp class="ph codeph">CCS_SSH_KEY=</samp><br>
<samp class="ph codeph"><var class="keyword varname">&lt;public_ssh_key&gt; </var></samp></div>
</td>
<td headers="d75728e505 "><div class="note note" data-hd-status="deprecated"><span class="notetitle">이 환경 변수는 더 이상 사용되지 않습니다. :</span> 대신 사용자 컨테이너에 대한 외부 액세스에는 <span class="ph"><samp class="ph codeph">bx ic</samp></span>
<samp class="ph codeph">exec</samp> 또는 <span class="ph"><samp class="ph codeph">bx ic</samp></span>
<samp class="ph codeph">attach</samp>를 사용하십시오. 자세한 정보는
<a href="container_security.html#container_cli_login_exec" title="실행 중인 컨테이너에 로그인해야 하는 경우 bx ic exec를 사용할 수 있습니다.">exec를 사용하여 컨테이너에 로그인</a>의 내용을 참조하십시오.</div>

<span class="ph">컨테이너를 작성할 때 이에 SSH 키를 추가하기 위해 <samp class="ph codeph">CCS_API_KEY</samp>를 사용할 수 있습니다.</span></td>
</tr>
<tr><td headers="d75728e503 "><div class="lines"><samp class="ph codeph">LOG_LOCATIONS=</samp><br>
<samp class="ph codeph"><var class="keyword varname">&lt;path_to_file&gt; </var></samp></div>
</td>
<td headers="d75728e505 "><span class="ph" id="gui__d42743e1430">컨테이너에서 모니터링할 로그 파일을 추가하려면 <samp class="ph codeph">LOG_LOCATIONS</samp>
환경 변수를 로그 파일의 경로와 함께 포함시키십시오.</span></td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</li>
<li class="step stepexpand" id="gui__bind_service_step">옵션: <span class="cmd">앱에 대한 기타 서비스를 정의하십시오. <span class="keyword">Bluemix</span> 영역의 <span class="keyword">Bluemix</span> 서비스를 컨테이너에 바인드하십시오. 
<span class="ph uicontrol">서비스 바인딩</span> 섹션에서 <span class="keyword">Bluemix</span> 서비스 인스턴스를 선택하고 <span class="ph uicontrol">추가</span>를 클릭하여 서비스를 컨테이너에 바인드하십시오. </span> 아직 영역에 추가된 <span class="keyword">Bluemix</span> 서비스가 없으면 서비스가 메뉴에 표시되지 않습니다. </li>
<li class="step stepexpand" id="gui__deploy"><span class="cmd">컨테이너를 배치하고 완료될 때까지 대기하십시오. <span class="ph uicontrol">작성</span>을 클릭하십시오.</span> 컨테이너가 작성될 때(잠시 시간이 걸릴 수 있음) <span class="keyword">Bluemix</span>에서도
컨테이너가 시작됩니다. <span class="ph uicontrol">CONTAINER HEALTH</span> 섹션에서 컨테이너의 상태를 확인하십시오.
작성이 완료되면 상태는 <span class="ph uicontrol">실행 중</span>입니다. </li>
</ol>
<div class="section result" id="gui__result_xh5_421_4z"><p>사용할 기존 IP 주소가 있기 때문에 <span class="ph uicontrol">공인 IP 주소</span>로 <span class="ph uicontrol">지정되지 않은 채로 두기</span>를 선택한 경우
컨테이너에 IP 주소를 바인드하십시오. 자세한 정보는
<a href="container_single_ui.html#container_cli_ips" title="공인 IP 주소를 요청하고 Bluemix의 컨테이너에 바인드합니다.">공인 IP 주소 요청 및 컨테이너에 바인드</a>의 내용을 참조하십시오.</p>

<div class="p" id="gui__wait">컨테이너에서 외부 앱에 연결하는 경우에는 컨테이너 프로세스를 시작한 후 최대 5분을 기다려야
지정된 IP 주소에 연결될 수 있습니다. 그런 후 다음 옵션 중 하나를 수행하여 앱이 컨테이너에서 작동하는지 확인할 수 있습니다. <ul id="gui__ul_yh5_421_4z"><li>공인 IP 주소와 포트를 포함하는 URL을 작성하여 앱을 브라우저에서 열 수 있습니다.
<p>예</p>
<span class="ph filepath">http://<var class="keyword varname">public_IP</var>:<var class="keyword varname">public_port</var></span>
<div class="steps note"><span class="notetitle">참고:</span> HTTP 엔드포인트를 노출하지 않는 서비스가 앱에 있는 경우 이 옵션은 브라우저에서 앱을 표시하지 않습니다. </div>
</li>
<li>Linux 또는 UNIX 명령행에서 <span class="ph filepath">nc -zv <var class="keyword varname">&lt;public_IP&gt;</var>
<var class="keyword varname">&lt;public_port&gt;</var></span>를
실행하여 서버가 지정된 포트를 청취하는지 확인하십시오. </li>
</ul>
</div>
</div><div class="section postreq" id="gui__postreq_zh5_421_4z"><p>다음으로 조직 관리자인 경우 조직의 컨테이너 비용 청구를 볼 수 있습니다. </p>

<ol id="gui__ol_a35_421_4z"><li><span class="ph">계정 세부사항의 조직 관리에서 조직을 선택하십시오. </span></li>
<li><span class="ph uicontrol">사용량 대시보드</span>를 선택하고 사용량 및 비용 청구 세부사항을 검토하십시오. </li>
</ol>
</div></div>
</article><article class="topic task nested1" role="article" aria-labelledby="d75728e738" lang="ko-kr" id="container_single_cli"><h2 class="topictitle2" id="d75728e738">명령행 인터페이스(CLI)를 사용하여 단일 컨테이너로 단기 태스크 실행</h2>
<div class="body taskbody"><p class="shortdesc"><samp class="ph codeph">run</samp> 명령을 사용하여 컨테이너를 작성합니다. 컨테이너는 그 안에 이미지를 포함해야 합니다. 아직 이미지가 없으면 조직의 개인용 이미지 레지스트리에서 기본적으로 사용할 수 있는 기본 IBM 인증 이미지 중
하나를 사용할 수 있습니다. </p>
<div class="section prereq"><div class="p" id="container_single_cli__prereq">시작하기 전에 다음과 같은 단계를 고려하십시오. <ul><li><span class="keyword">Bluemix</span> 영역에서 컨테이너를 작성하려면 이 영역에 대해 개발자 역할이 있어야 합니다.
각 역할의 권한 및
역할 편집 방법에 대한 자세한 정보는 <span class="ph"><a href="../iam/users_roles.html">사용자 및 역할</a></span>의 내용을 참조하십시오.</li>
<li id="container_single_cli__identify_images"><samp class="ph codeph"><span class="ph"><samp class="ph codeph">bx ic</samp></span> images</samp> 명령을
실행하여 컨테이너에서 사용할 기존 이미지를 조직의 개인용 이미지 레지스트리에서 식별하십시오. 레지스트리에 이미지를
추가하려면 <a href="container_images_adding_ov.html#container_images_adding_ov" title="컨테이너 이미지는 작성하는 모든 컨테이너의 기초가 됩니다. 이미지는 빌드 아티팩트(예: 앱, 앱의 구성 및 이의 종속 항목) 및 이미지를 빌드하는 지시사항이 포함된 파일인 Dockerfile에서 작성됩니다. 컨테이너 이미지를 실행 파일(.exe 또는 .bin)로서 생각하십시오. 실행 가능 앱 파일을 실행하는 즉시 앱의 인스턴스가 작성됩니다. 컨테이너를 실행하면 이미지에서 컨테이너 인스턴스가 작성됩니다.">조직의 개인용 Bluemix 이미지 레지스트리에 Docker 이미지 추가</a>의 내용을 참조하십시오. </li>
<li>IP 주소를 새로 작성하는 대신 사용할 수 있는 영역의 기존 IP 주소가 있는지 여부를 확인하십시오.
자세한 정보는
<a href="container_single_ui.html#container_cli_ips_list" title="단일 컨테이너가 인터넷에서 액세스 가능하도록 하려면 단일 컨테이너에 공인 IP 주소를 바인드해야 합니다. IP 주소를 요청하기 전에, 조직에 이미 지정된 공인 IP 주소의 목록을 검토하고 이러한 기존 IP 주소 중 하나를 사용할 수 있는지를 확인하십시오.">명령행 인터페이스(CLI)를 사용하여 조직에 대한 기존 공인 IP 주소 찾기</a>의 내용을 참조하십시오.</li>
<li><span class="keyword">Bluemix</span> 서비스를 컨테이너에 바인드하고자 함을 아는 경우에는
<span class="keyword">Bluemix</span> 서비스를 영역에 추가하십시오. 자세한 정보는
<a href="container_integrations.html#container_integrations_binding" title="IBM Bluemix에는 서비스 목록이 있으며 앱 개발자 대신 해당 서비스를 관리합니다. 사용할 컨테이너의 Bluemix 서비스를 추가하려면 이 서비스의 인스턴스를 요청하고 서비스를 컨테이너에 바인드해야 합니다.">Bluemix GUI에서 서비스 바인딩</a>의 내용을 참조하십시오.</li>
<li id="container_single_cli__create_shared_volume">여러 컨테이너에서 파일에 대한 액세스를 허용하는 공유 디스크를 원하는 경우에는
컨테이너를 작성하기 전에 볼륨을 작성하십시오. 자세한 정보는
<a href="container_volumes_ov.html#container_volumes_cli" title="볼륨은 앱이 작성하는 데이터 또는 앱이 실행해야 하는 파일의 지속적 스토리지 위치입니다. 명령행에서 컨테이너의 볼륨을 작성할 수 있습니다.">명령행(CLI)에서 볼륨 작성</a>의 내용을 참조하십시오.</li>
</ul>
</div>
</div><p class="li stepsection">컨테이너를 작성하십시오. </p><ol class="steps"><li class="step stepexpand"><span class="cmd">조직의 개인용 이미지 레지스트리에 있는 기존 IP 주소 및 기존 이미지를 사용하여 컨테이너를 작성하십시오.*</span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> run -p <var class="keyword varname">&lt;ip-address&gt;</var>:<var class="keyword varname">&lt;port_on_IP&gt;</var>:<var class="keyword varname">&lt;public_port&gt;</var> -e <var class="keyword varname">&lt;env_variable&gt;</var> -m <var class="keyword varname">&lt;container_size&gt;</var> --name <var class="keyword varname">&lt;container_name&gt;</var> --volume <var class="keyword varname">&lt;volname:mount_path&gt;</var> registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;namespace&gt;</var>/<var class="keyword varname">&lt;image_name_or_id&gt;</var></code></pre>

<div class="steps note"><span class="notetitle">참고:</span> <span class="ph" id="container_single_cli__d41700e176">*이 명령에서 <a href="container_cli_cfic_install.html#container_cli_login" title="CLI를 설치한 후 CLI를 사용하기 위해 로그인합니다."><span class="keyword">IBM
Bluemix Container Service</span></a>에 로그인하고
환경 변수를 기본 Docker 명령을 사용하도록 설정한 경우 <samp class="ph codeph"><span class="ph">bx ic</span></samp>를
<samp class="ph codeph">docker</samp>로 대체할 수 있습니다. </span><span class="ph" id="container_single_cli__d41700e187">이 주제에서 별표(*)로 표시된 모든 단계에서 기본 Docker
명령을 사용할 수 있습니다. </span></div>

<p>예</p>

<div class="p">다음 예는 아래 세부사항을 포함하는 단일 컨테이너를 작성합니다. <ul><li>이름: <var class="keyword varname">my_container</var></li>
<li>크기: <var class="keyword varname">64MB</var></li>
<li>이미지: <var class="keyword varname">ibmliberty</var></li>
<li>마운트된 볼륨: <var class="keyword varname">myvol</var></li>
<li>노출된 공용 포트: <var class="keyword varname">9080</var></li>
<li>바인드된 IP 주소: <var class="keyword varname">192.0.2.23</var></li>
<li>사용자 정의 로그 파일 위치: 표준 Ubuntu 로그 파일. 사용자 정의 로그 파일 위치의 로그는 컨테이너를 작성한 후 Kibana에서 볼 수 있습니다. </li>
</ul>
</div>

<pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> run -p 192.0.2.23:9080:9080 -e <span class="q">"LOG_LOCATION=/var/log/dpkg.log"</span> -m 64 --name my_container --volume myvol:/var/tmp registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/ibmliberty </code></pre>

컨테이너는 작성되면 시작됩니다. 컨테이너가 배치되면 컨테이너의 ID가 표시됩니다.</li>
<li class="step stepexpand">옵션: <span class="cmd">실행 중인 컨테이너를 나열하십시오.*</span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ps</code></pre>
</li>
</ol>
<div class="section postreq"><div class="p">컨테이너에서 외부 앱에 연결하는 경우에는 컨테이너 프로세스를 시작한 후 최대 5분을 기다려야
지정된 IP 주소에 연결될 수 있습니다. 그런 후 다음 옵션 중 하나를 수행하여 앱이 컨테이너에서 작동하는지 확인할 수 있습니다. <ul id="container_single_cli__d41705e365"><li>공인 IP 주소와 포트를 포함하는 URL을 작성하여 앱을 브라우저에서 열 수 있습니다.
<p>예</p>
<span class="ph filepath">http://<var class="keyword varname">public_IP</var>:<var class="keyword varname">public_port</var></span>
<div class="steps note"><span class="notetitle">참고:</span> HTTP 엔드포인트를 노출하지 않는 서비스가 앱에 있는 경우 이 옵션은 브라우저에서 앱을 표시하지 않습니다. </div>
</li>
<li>Linux 또는 UNIX 명령행에서 <span class="ph filepath">nc -zv <var class="keyword varname">&lt;public_IP&gt;</var>
<var class="keyword varname">&lt;public_port&gt;</var></span>를
실행하여 서버가 지정된 포트를 청취하는지 확인하십시오. </li>
</ul>
</div>

<p>다음으로 조직 관리자인 경우 조직의 컨테이너 비용 청구를 볼 수 있습니다. </p>

<div class="p"><ol><li>사용자 아바타를 클릭하십시오. </li>
<li><span class="ph uicontrol">계정</span>을 클릭하십시오. </li>
<li><span class="ph uicontrol">+</span> 단추를 클릭하여 조직을 펼치십시오. </li>
<li><span class="ph uicontrol">사용량 대시보드</span>를 선택하고 사용량 및 비용 청구 세부사항을 검토하십시오. </li>
</ol>
<span class="ph">자세한 정보를 보려면 <span class="ph"><a href="../admin/account.html">계정 관리</a></span>로 이동하십시오. </span></div>
</div></div>
<aside role="complementary" aria-labelledby="d75728e738"></aside></article><article class="topic task nested1" role="article" aria-labelledby="d75728e1052" lang="ko-kr" id="container_single_updating"><h2 class="topictitle2" id="d75728e1052">명령행 인터페이스(CLI)를 사용하여 단일 컨테이너에서 단기 태스크 업데이트</h2>
<div class="body taskbody"><p class="shortdesc">앱을 업데이트하려면 새 컨테이너를 배치해야 합니다. 새 이미지를 푸시하는 경우
컨테이너는 자동으로 다시 시작되지 않습니다. </p>
<div class="section context"><div class="tablenoborder"><table summary="" id="container_single_updating__updating_group_cli_table" class="defaultstyle"><caption><span class="tablecap">표 2. 앱 업데이트를 위한 선택적 도구</span></caption><thead><tr><th id="d75728e1117" class="thleft">업데이트 도구</th>
<th id="d75728e1119" class="thleft">설명</th>
</tr>
</thead>
<tbody><tr><td headers="d75728e1117 "><span class="keyword">Delivery Pipeline</span></td>
<td headers="d75728e1119 ">사용자가 사용할 수 있는 <span class="keyword">Bluemix</span> 서비스인
<span class="keyword">Delivery Pipeline</span>을 사용하여
<span class="keyword">Bluemix</span>에 대한 컨테이너 배치 및 앱 빌드를 자동화합니다. 자세한 정보는
<a href="container_integrations.html#container_single_pipeline_ov" title="Delivery Pipeline에서 단일 컨테이너의 빌드 및 배치를 자동화합니다.">Delivery Pipeline을 사용하여 단일 컨테이너 작성</a>의 내용을 참조하십시오.</td>
</tr>
<tr><td headers="d75728e1117 ">UrbanCode Deploy</td>
<td headers="d75728e1119 ">UrbanCode Deploy를 사용하여
<span class="keyword">Bluemix</span>에 대한 컨테이너 배치 및 앱 빌드를 자동화합니다. 
UrbanCode Deploy 구매에 대한 자세한 정보는
<a href="http://www.ibm.com/software/products/en/ucdep" rel="external" target="_blank" title="(새로운 탭이나 창으로 열기)">IBM UrbanCode
Deploy</a> 제품 페이지를 참조하십시오. </td>
</tr>
<tr><td headers="d75728e1117 "><span class="keyword">IBM
Bluemix Container Service</span> CLI를 사용하여 직접 앱 업데이트</td>
<td headers="d75728e1119 ">앱을 직접 업데이트하려면 이 태스크의 단계를 완료하십시오. </td>
</tr>
</tbody>
</table>
</div>
</div><p class="li stepsection"><span class="keyword">IBM
Bluemix Container Service</span> CLI를
사용하여 직접 컨테이너를 업데이트하려면 다음을 수행하십시오. </p><ol class="steps"><li class="step stepexpand"><span class="cmd">로컬에서 앱을 업데이트하십시오. </span></li>
<li class="step stepexpand"><span class="cmd"><span class="keyword">Bluemix</span>에서 직접 이미지를 빌드하거나, <span class="keyword">Bluemix</span>에
푸시하기 전에 로컬로 이미지를 빌드하고 테스트하십시오.</span> <ul><li><span class="keyword">Bluemix</span>에서 직접 이미지를 빌드하려면 다음 명령을 실행하십시오.*<div class="note tip"><span class="tiptitle">팁:</span> <span class="ph"><samp class="ph codeph"><span class="ph">bx ic</span> namespace-get</samp>을 실행하여
네임스페이스를 검색하고 <var class="keyword varname">&lt;my_namespace&gt;</var>를 자신의 네임스페이스 정보로 대체하십시오. </span></div>
<pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> build -t registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/<var class="keyword varname">&lt;image_name&gt;</var>:<var class="keyword varname">&lt;tag&gt;</var> <var class="keyword varname">&lt;dockerfile_location&gt;</var></code></pre>
예<pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> build -t registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">my_namespace</var>/<var class="keyword varname">my_image</var>:<var class="keyword varname">v1</var>.</code></pre>
<div class="steps note"><span class="notetitle">참고:</span> <span class="ph" id="container_single_updating__d43250e236">*이 명령에서 <a href="container_cli_cfic_install.html#container_cli_login" title="CLI를 설치한 후 CLI를 사용하기 위해 로그인합니다."><span class="keyword">IBM
Bluemix Container Service</span></a>에 로그인하고
환경 변수를 기본 Docker 명령을 사용하도록 설정한 경우 <samp class="ph codeph"><span class="ph">bx ic</span></samp>를
<samp class="ph codeph">docker</samp>로 대체할 수 있습니다. </span><span class="ph" id="container_single_updating__d43250e254">이 주제에서 별표(*)로 표시된 모든 단계에서 기본 Docker
명령을 사용할 수 있습니다. </span></div>
</li>
<li>로컬로 이미지를 빌드한 후에 해당 이미지를 <span class="keyword">Bluemix</span>에 푸시하려면 다음 단계를 따르십시오.<div class="p"><ol type="a"><li><span class="keyword">IBM
Bluemix Container Service</span>의 플러그인을 사용 중인 경우에는 다시 로그인하십시오. <samp class="ph codeph">docker</samp> 명령을
로컬 시스템의 Docker 엔진에 보내도록, 옵션 2의 환경 변수를
설정하지 마십시오.<div class="p"><pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> init</code></pre>
</div>
</li>
<li>Dockerfile에서 로컬로 이미지를 빌드하십시오.<div class="p"><pre class="codeblock"><code>docker build -t <var class="keyword varname">&lt;image_name&gt;</var>:<var class="keyword varname">&lt;tag&gt;</var> <var class="keyword varname">&lt;dockerfile_location&gt;</var></code></pre>
</div>
<div class="p">예<pre class="codeblock"><code>docker build -t <var class="keyword varname">my_ibmliberty_image</var>:<var class="keyword varname">v1</var> .</code></pre>
</div>
</li>
<li>다음 명령을 사용하여 새 앱이 로컬로 실행되는지 테스트하도록 이미지에서 컨테이너를 실행하십시오.
여기서 <var class="keyword varname">Port</var>는 HTTP 트래픽에 사용되는 포트입니다. <div class="p"><pre class="codeblock"><code>docker run -d --name <var class="keyword varname">&lt;container_name&gt;</var> <var class="keyword varname">&lt;image_name&gt;</var></code></pre>
</div>
<div class="p">예<pre class="codeblock"><code>docker run -d --name <var class="keyword varname">my_container</var> <var class="keyword varname">my_ibmliberty_image</var></code></pre>
</div>
<p>앱이
올바로 실행 중이면 컨테이너 ID가 CLI 출력에 표시됩니다. 컨테이너 관련
로그를 검토하려면 <samp class="ph codeph">docker logs
<var class="keyword varname">&lt;container_name_or_id&gt;</var>.</samp>를 실행하십시오. </p>
</li>
<li id="container_single_updating__d43250e335">개인용 <span class="keyword">Bluemix</span> 레지스트리와 새 이름을 사용하여 로컬 이미지에 태그를 지정하십시오. <span class="ph">이미지 이름에는 소문자의 영숫자 문자 또는 밑줄(_)만 사용하십시오.
하이픈(-) 또는 슬래시(/) 등의 기타 기호를 사용하면 이미지가 이미지 레지스트리에
푸시되지 않습니다.</span><div class="p"><pre class="codeblock"><code>docker tag <var class="keyword varname">&lt;current_image_name_or_ID&gt;</var>:<var class="keyword varname">&lt;optional_tag&gt;</var> registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/<var class="keyword varname">&lt;new_image_name&gt;</var>:<var class="keyword varname">&lt;optional_tag&gt;</var> </code></pre>
</div>
<p>예</p>
<div class="p"><pre class="codeblock"><code>docker tag <var class="keyword varname">my_ibmliberty_image</var> registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/<var class="keyword varname">my_ibmliberty_image</var></code></pre>
</div>
</li>
<li>다음 명령을 사용하여 개인용 <span class="keyword">Bluemix</span>
레지스트리에 이미지를 푸시하십시오. <div class="p"><pre class="codeblock"><code>docker push registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/<var class="keyword varname">&lt;image_name&gt;</var></code></pre>
</div>
<div class="p">예<pre class="codeblock"><code>docker push registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">my_namespace</var>/<var class="keyword varname">my_ibmliberty_image</var></code></pre>
</div>
</li>
</ol>
</div>
<div class="note important"><span class="importanttitle">중요사항:</span> <span class="ph">개인용 <span class="keyword">Bluemix</span> 레지스트리에 이미지를 푸시하면 이미지와 관련하여 보고된
크기가 로컬 Docker 엔진에 있는 동일한 이미지의 크기보다 작습니다. 크기가 다르다고 해서 이미지를 푸시할 때 문제가 발생한 것은 아닙니다.
이미지의 압축 크기는 <span class="keyword">IBM
Bluemix Container Service</span>에서 보고됩니다. </span></div>
</li>
</ul>
</li>
<li class="step stepexpand"><span class="cmd">컨테이너에서 공인 IP 주소를 바인드 해제하십시오. </span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ip-unbind <var class="keyword varname">&lt;public_IP_address&gt;</var> <var class="keyword varname">&lt;container_name_or_id&gt;</var></code></pre>
 <p>컨테이너가 더 이상 IP 주소에 바인드되지 않지만, 해당 IP가 아직 사용자 조직의 공인 IP 할당량으로 계수됩니다. </p>
</li>
<li class="step stepexpand"><span class="cmd">다음 명령을 실행하여 IP 주소가 바인드 해제되었는지 확인하십시오.*</span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> inspect <var class="keyword varname">&lt;container_name_or_id&gt;</var></code></pre>


<p><samp class="ph systemoutput">PublicIpAddress</samp>의 값이 비어 있지 않은 경우에는
몇 분 정도 기다린 후 다음 단계를 계속 진행하기 전에 명령을 다시 실행하십시오. </p>
</li>
<li class="step stepexpand"><span class="cmd">기존 컨테이너에서 IP 주소가 제거되었으면 업데이트된 이미지를 사용하여 다른 업데이트를
작성하십시오.*</span> <pre class="codeblock"><code><span class="ph"><span class="ph"><samp class="ph codeph">bx ic</samp></span><span class="ph" id="container_single_updating__d43264e3568"> run [-p PORT] [-P] [-d] [-e ENV] [--env-file
ENVFILE] [-it] [--link NAME:ALIAS] [-m MEMORY] --name NAME [--volume VOLUME:/DIRECTORY_PATH] IMAGE [CMD [CMD ...]] </span></span></code></pre>
</li>
<li class="step stepexpand"><span class="cmd">IP 주소를 새 컨테이너에 바인드하십시오. </span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ip-bind <var class="keyword varname">&lt;public_IP_address&gt;</var> <var class="keyword varname">&lt;container_name_or_id&gt;</var></code></pre>
</li>
<li class="step stepexpand">옵션: <span class="cmd">이전 컨테이너를 삭제하십시오.*</span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> rm <var class="keyword varname">&lt;container_name_or_id&gt;</var></code></pre>
</li>
</ol>
</div>
<aside role="complementary" aria-labelledby="d75728e1052"></aside></article><article class="topic task nested1" role="article" aria-labelledby="d75728e1511" lang="ko-kr" id="container_linking"><h2 class="topictitle2" id="d75728e1511">명령행 인터페이스(CLI)를 사용하여 단일 컨테이너 링크</h2>
<div class="body taskbody"><p class="shortdesc">컨테이너가 동일한 영역의 다른 컨테이너에 링크되는 경우, <span class="keyword">IBM
Bluemix Container Service</span>는
소스 컨테이너의 수신 컨테이너에 호스트 항목을 작성합니다. 자주 변경될 수 있는 특정 IP 주소 대신에 별명을 사용하여 소스 컨테이너를 참조할 수 있습니다. </p>
<div class="section context"><p>단일 컨테이너가 이미지(예: <samp class="ph codeph">dbimage</samp>)를 실행 중인 다른 컨테이너와
통신하게 하려고 할 때마다 호스트 이름의 별명(예: <samp class="ph codeph">dbserver</samp>)을 사용하여
컨테이너를 처리할 수 있습니다. 이 기능을 사용하면 해당 IP 주소 또는
실제 이름과는 무관하게 <samp class="ph codeph">dbserver</samp> 호스트 이름을 사용하여 데이터베이스
서버 이미지를 참조하는 <samp class="ph codeph">webserver</samp> 이미지를 작성할 수 있습니다. 구성 또는 IP 정보를
핸드오프(hand-off)하지 않고도 동일한 이미지의 쌍의 다수의 인스턴스를 실행할 수 있습니다. 
항상 데이터베이스 서버를 <samp class="ph codeph">dbserver</samp>로 참조할 수 있습니다. </p>

</div><ol class="steps"><li class="step stepexpand"><span class="cmd">다음 명령을 실행하여 소스 컨테이너를 작성하십시오.*</span> <div class="note tip"><span class="tiptitle">팁:</span> 포트를 공개하려면 반드시 <samp class="ph codeph">-p</samp> 옵션을 포함하십시오. 이 옵션은 수신 컨테이너에 포트 번호를 노출합니다. Dockerfile에서 EXPOSE 명령문으로 이미지에서
노출된 포트는 현재 링크 중인 런타임에 의해 사용되지 않습니다.</div>

<div class="note tip"><span class="tiptitle">팁:</span> <span class="ph"><samp class="ph codeph"><span class="ph">bx ic</span> namespace-get</samp>을 실행하여
네임스페이스를 검색하고 <var class="keyword varname">&lt;my_namespace&gt;</var>를 자신의 네임스페이스 정보로 대체하십시오. </span></div>

<pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> run -p <var class="keyword varname">&lt;port&gt;</var> --name <var class="keyword varname">&lt;source_container_name&gt;</var> registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/<var class="keyword varname">&lt;source_container_image_name&gt;</var> </code></pre>
예<pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> run -p <var class="keyword varname">17546</var> --name <var class="keyword varname">source</var> registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/<var class="keyword varname">dbimage</var> </code></pre>

<div class="steps note"><span class="notetitle">참고:</span> <span class="ph" id="container_linking__d36729e176">*이 명령에서 <a href="container_cli_cfic_install.html#container_cli_login" title="CLI를 설치한 후 CLI를 사용하기 위해 로그인합니다."><span class="keyword">IBM
Bluemix Container Service</span></a>에 로그인하고
환경 변수를 기본 Docker 명령을 사용하도록 설정한 경우 <samp class="ph codeph"><span class="ph">bx ic</span></samp>를
<samp class="ph codeph">docker</samp>로 대체할 수 있습니다. </span><span class="ph" id="container_linking__d36729e187">이 주제에서 별표(*)로 표시된 모든 단계에서 기본 Docker
명령을 사용할 수 있습니다. </span></div>
</li>
<li class="step stepexpand"><span class="cmd">수신 컨테이너를 작성하고, 다음 명령을 실행하여 이를 소스 컨테이너에 링크하십시오. *</span> 별명인 경우에는 소스 컨테이너에서 사용되는 이미지에 대한 사용자 정의 이름을 선택하십시오. <span class="keyword option">-p</span> 옵션을 여러 번 포함하여
여러 개의 수신 컨테이너 포트를 호스트 컨테이너에 노출할 수 있습니다. <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> run -p <var class="keyword varname">&lt;port&gt;</var> -p <var class="keyword varname">&lt;port&gt;</var> --name <var class="keyword varname">&lt;recipient_container_name&gt;</var> --link <var class="keyword varname">&lt;source_container_name&gt;</var>:<var class="keyword varname">&lt;alias&gt;</var> registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/<var class="keyword varname">&lt;recipient_container_image_name&gt;</var> </code></pre>
예<pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> run -p 12534 -p 15256 --name <var class="keyword varname">recipient</var> --link <var class="keyword varname">source</var>:<var class="keyword varname">dbserver</var> registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/<var class="keyword varname">webserver</var> </code></pre>

<p>컨테이너가 링크되면 수신 컨테이너의 ID가 표시됩니다.</p>
</li>
<li class="step stepexpand">옵션: <span class="cmd"><samp class="ph codeph">exec</samp>를 통해 컨테이너에 로그인하여 링크에 의해 삽입된 환경 변수를 확인하십시오.* </span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> exec -it <var class="keyword varname">&lt;recipient_container_name&gt;</var> bash </code></pre>
 <div class="p">bash 창에서 <samp class="ph codeph">env</samp> 명령을 실행하여 별명의 세부사항을 보십시오. <pre class="codeblock"><code>"Env": [
    "<var class="keyword varname">&lt;alias&gt;</var>_PORT_&lt;source_container_port&gt;/tcp_TCP_PORT=&lt;source_container_port&gt;/tcp",
    "<var class="keyword varname">&lt;alias&gt;</var>_PORT_&lt;source_container_port&gt;/tcp_TCP=tcp://<var class="keyword varname">&lt;recipient_container_private_IP&gt;</var>:&lt;source_container_port&gt;/tcp",
    "<var class="keyword varname">&lt;alias&gt;</var>_ENV_space_id=<var class="keyword varname">&lt;space_ID&gt;</var>",
    "logging_password=",
    "space_id=<var class="keyword varname">&lt;space_ID&gt;</var>",
    "logstash_target=logs.opvis.bluemix.net:9091",
    "<var class="keyword varname">&lt;alias&gt;</var>_PORT_<var class="keyword varname">&lt;source_container_port&gt;</var>/tcp_TCP_ADDR=<var class="keyword varname">&lt;recipient_container_private_ip&gt;</var>",
    "<var class="keyword varname">&lt;alias&gt;</var>_ENV_metrics_target=metrics.opvis.bluemix.net:9095",
    "<var class="keyword varname">&lt;alias&gt;</var>_NAME=/<var class="keyword varname">&lt;recipient_container&gt;</var>/<var class="keyword varname">&lt;alias&gt;</var>",
    "<var class="keyword varname">&lt;alias&gt;</var>_ENV_logstash_target=logs.opvis.bluemix.net:9091",
    "<var class="keyword varname">&lt;alias&gt;</var>_ENV_logging_password=",
    "<var class="keyword varname">&lt;alias&gt;</var>_PORT_<var class="keyword varname">&lt;source_container_port&gt;</var>/tcp_TCP_PROTO=tcp",
    "metrics_target=metrics.opvis.bluemix.net:9095"
],</code></pre>
</div>
</li>
</ol>
</div>
<aside role="complementary" aria-labelledby="d75728e1511"></aside></article><article class="topic task nested1" role="article" aria-labelledby="d75728e1824" lang="ko-kr" id="container_cli_ips"><h2 class="topictitle2" id="d75728e1824">공인 IP 주소 요청 및 컨테이너에 바인드</h2>
<div class="body taskbody"><p class="shortdesc">공인 IP 주소를 요청하고 <span class="keyword">Bluemix</span>의 컨테이너에 바인드합니다. </p>
<div class="section prereq"><div class="steps note"><span class="notetitle">참고:</span> 공인 IP 주소 바인딩은 단일 컨테이너로(부터) 전송되는 데이터를 암호화하는 SSL 인증서를 포함하지 않습니다. 앱에서 SSL 암호화를 요구하는 경우 자체 SSL 솔루션을 구현하거나 단일 컨테이너 대신 컨테이너 그룹을 사용할 수 있습니다. 컨테이너 그룹은 이미 SSL 인증서를 포함하는 공용 라우트에 바인드되므로 추가 구성 없이 HTTPS로 컨테이너 그룹에 액세스할 수 있습니다. 자세한 정보는 <a href="container_ha.html#container_group_ui" title="Bluemix GUI에서 확장 가능한 그룹 컨테이너를 작성하고 배치합니다. 컨테이너 그룹에는 동일한 이미지를 실행하는 두 개 이상의 컨테이너가 포함됩니다. 확장성 및 신뢰성이 요구되는 워크로드가 포함된 장기적 서비스를 실행하거나 필요한 스케일로 테스트할 때 컨테이너 그룹을 사용하십시오.">Bluemix GUI로 컨테이너 그룹 작성</a>을 참조하십시오. </div>

<p>시작하기 전에 새로 작성하는 대신 사용할 수 있는 공인 IP 주소가 영역에 대해 존재하는지를 확인하려면 <a href="container_single_ui.html#container_cli_ips_list" title="단일 컨테이너가 인터넷에서 액세스 가능하도록 하려면 단일 컨테이너에 공인 IP 주소를 바인드해야 합니다. IP 주소를 요청하기 전에, 조직에 이미 지정된 공인 IP 주소의 목록을 검토하고 이러한 기존 IP 주소 중 하나를 사용할 수 있는지를 확인하십시오.">명령행 인터페이스(CLI)를 사용하여 조직에 대한 기존 공인 IP 주소 찾기</a>의 내용을 참조하십시오. </p>
</div><ol class="steps"><li class="step stepexpand"><span class="cmd">공인 IP 주소를 요청하십시오. </span>  공인 IP 주소를 요청할 때 공인 IP 주소 풀에서 하나의 랜덤 주소가 영역에 할당됩니다. 영역에 할당된 동안에는 IP 주소가 변경되지 않습니다. <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ip-request</code></pre>
</li>
<li class="step stepexpand"><span class="cmd">IP 주소를 기록해 놓으십시오.</span></li>
<li class="step stepexpand"><span class="cmd">새 컨테이너 또는 실행 중인 기존 컨테이너에 주소를 바인드하십시오.</span> <ul class="ul choices"><li class="li choice">실행 중인 기존 컨테이너에 바인드하려면 다음을 수행하십시오.<pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ip-bind <var class="keyword varname">&lt;public_IP_address&gt;</var> <var class="keyword varname">&lt;container_name_or_id&gt;</var></code></pre>
예<pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ip-bind 192.0.2.23 my_container</code></pre>
</li>
<li class="li choice">새 컨테이너에 바인드하려면 다음을 수행하십시오.<pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> run -p <var class="keyword varname">&lt;ip-address&gt;</var>:<var class="keyword varname">&lt;container-port&gt;</var>:<var class="keyword varname">&lt;container-port&gt;</var> --name <var class="keyword varname">&lt;container_name&gt;</var> registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/<var class="keyword varname">&lt;image_name&gt;</var></code></pre>
</li>
</ul>
</li>
</ol>
<div class="section result">바인드 요청은 즉각 작성되지만, 컨테이너의 IP 주소에 연결하는 데는 잠시 시간이 걸릴 수도 있습니다.</div></div>
<aside role="complementary" aria-labelledby="d75728e1824"></aside><article class="topic task nested2" role="article" aria-labelledby="d75728e1975" lang="ko-kr" id="container_cli_ips_list"><h3 class="topictitle3" id="d75728e1975">명령행 인터페이스(CLI)를 사용하여 조직에 대한 기존 공인 IP 주소 찾기</h3>
<div class="body taskbody"><p class="shortdesc">단일 컨테이너가 인터넷에서 액세스 가능하도록 하려면
단일 컨테이너에 공인 IP 주소를 바인드해야 합니다. IP 주소를 요청하기 전에, 조직에 이미 지정된 공인 IP 주소의 목록을 검토하고 이러한 기존 IP 주소 중 하나를 사용할 수 있는지를 확인하십시오.</p>
<div class="section context"><div class="steps note"><span class="notetitle">참고:</span> 공인 IP 주소 바인딩은 단일 컨테이너로(부터) 전송되는 데이터를 암호화하는 SSL 인증서를 포함하지 않습니다. 앱에서 SSL 암호화를 요구하는 경우 자체 SSL 솔루션을 구현하거나 단일 컨테이너 대신 컨테이너 그룹을 사용할 수 있습니다. 컨테이너 그룹은 이미 SSL 인증서를 포함하는 공용 라우트에 바인드되므로 추가 구성 없이 HTTPS로 컨테이너 그룹에 액세스할 수 있습니다. 자세한 정보는 <a href="container_ha.html#container_group_ui" title="Bluemix GUI에서 확장 가능한 그룹 컨테이너를 작성하고 배치합니다. 컨테이너 그룹에는 동일한 이미지를 실행하는 두 개 이상의 컨테이너가 포함됩니다. 확장성 및 신뢰성이 요구되는 워크로드가 포함된 장기적 서비스를 실행하거나 필요한 스케일로 테스트할 때 컨테이너 그룹을 사용하십시오.">Bluemix GUI로 컨테이너 그룹 작성</a>을 참조하십시오. </div>
</div><div class="step"><span class="cmd">영역에 사용 가능한 공인 IP 주소를 나열하십시오.</span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ips</code></pre>
</div>
<div class="section postreq">IP 주소가 없거나 새로 요청하려는 경우에는 다음 옵션 중 하나를
선택할 수 있습니다. <span class="keyword">Bluemix</span> GUI를 사용하여
단일 컨테이너를 작성할 때나 명령행에서 <samp class="ph codeph"><span class="ph"><samp class="ph codeph">bx ic</samp></span> ip-request</samp>를 실행할 때
IP 주소를 요청할 수 있습니다. 명령행을 사용하여 IP 주소를 요청하려면 <a href="container_single_ui.html#container_cli_ips" title="공인 IP 주소를 요청하고 Bluemix의 컨테이너에 바인드합니다.">공인 IP 주소 요청 및 컨테이너에 바인드</a>의 내용을 참조하십시오. </div></div>
<aside role="complementary" aria-labelledby="d75728e1975"></aside></article><article class="topic task nested2" role="article" aria-labelledby="d75728e2075" lang="ko-kr" id="container_cli_ips_unbind"><h3 class="topictitle3" id="d75728e2075">컨테이너에서 공인 IP 주소 바인드 해제</h3>
<div class="body taskbody"><p class="shortdesc">컨테이너에서 공인 IP 주소를 바인드 해제할 수 있지만, 다른 컨테이너에서 아직
해당 IP 주소를 사용할 수 있으며 사용자 조직의 공인 IP 할당량으로 계수됩니다. </p>
<ol class="steps"><li class="step stepexpand" id="container_cli_ips_unbind__unbind"><span class="cmd">컨테이너에서 공인 IP 주소를 바인드 해제하십시오. </span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ip-unbind <var class="keyword varname">&lt;public_IP_address&gt;</var> <var class="keyword varname">&lt;container_name_or_id&gt;</var></code></pre>
 <p>컨테이너가 더 이상 IP 주소에 바인드되지 않지만, 해당 IP가 아직 사용자 조직의 공인 IP 할당량으로 계수됩니다. </p>
</li>
<li class="step stepexpand"><span class="cmd">IP 주소의 바인드 해제가 완료되었는지 확인하십시오. </span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ips</code></pre>
</li>
</ol>
</div>
<aside role="complementary" aria-labelledby="d75728e2075"></aside></article><article class="topic task nested2" role="article" aria-labelledby="d75728e2157" lang="ko-kr" id="container_cli_ips_remove"><h3 class="topictitle3" id="d75728e2157">할당량에서 공인 IP 주소 제거</h3>
<div class="body taskbody"><p class="shortdesc">공인 IP 주소를 사용 중이 아니거나 새 IP 주소를 요청하기 위해 하나를 삭제해야 하는 경우에는 사용자 조직의 할당량에서 공인 IP 주소를 제거할 수 있습니다. </p>
<div class="section prereq">시작하기 전에 공인 IP 주소를 사용 중인 컨테이너에서 해당 공인 IP 주소를 바인드 해제하십시오. </div><ol class="steps"><li class="step stepexpand"><span class="cmd">조직의 할당량에서 IP 주소를 제거하십시오. </span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ip-release <var class="keyword varname">&lt;public_IP_address&gt;</var> </code></pre>
</li>
<li class="step stepexpand">옵션: <span class="cmd">IP 주소가 더 이상 할당된 주소로 나열되지 않는지 확인하십시오. </span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ips</code></pre>
</li>
</ol>
</div>
<aside role="complementary" aria-labelledby="d75728e2157"></aside></article></article><article class="topic task nested1" role="article" aria-labelledby="d75728e2237" lang="ko-kr" id="container_single_remove"><h2 class="topictitle2" id="d75728e2237">단일 컨테이너 제거</h2>
<div class="body taskbody"><p class="shortdesc">할당량의 사용을 최대화하려면 사용하지 않는 컨테이너를 가끔씩 제거하십시오. </p>
<ol class="steps"><li class="step stepexpand"><span class="cmd">다음 방법 중 하나를 사용하여 컨테이너를 제거하십시오. </span> <ul class="ul choices"><li class="li choice"><span class="keyword">Bluemix</span> GUI 사용<ol type="a"><li><span class="keyword">Bluemix</span> 대시보드에서 삭제하려는 컨테이너를 선택하십시오. </li>
<li><span class="ph uicontrol">추가 조치...</span> 메뉴를 펼치고 <span class="ph uicontrol">삭제</span>를 클릭하십시오. </li>
</ol>
<ul><li>컨테이너의 타일에서 기어 아이콘을 클릭하고 <span class="ph uicontrol">컨테이너
삭제</span>를 클릭하십시오. </li>
</ul>
</li>
<li class="li choice">CLI에서
*<pre class="codeblock"><code><span class="ph"><span class="ph"><samp class="ph codeph">bx ic</samp></span> rm [-f] CONTAINER [CONTAINER] </span></code></pre>
<div class="steps note"><span class="notetitle">참고:</span> <span class="ph" id="container_single_remove__d42527e176">*이 명령에서 <a href="container_cli_cfic_install.html#container_cli_login" title="CLI를 설치한 후 CLI를 사용하기 위해 로그인합니다."><span class="keyword">IBM
Bluemix Container Service</span></a>에 로그인하고
환경 변수를 기본 Docker 명령을 사용하도록 설정한 경우 <samp class="ph codeph"><span class="ph">bx ic</span></samp>를
<samp class="ph codeph">docker</samp>로 대체할 수 있습니다. </span><span class="ph" id="container_single_remove__d42527e187">이 주제에서 별표(*)로 표시된 모든 단계에서 기본 Docker
명령을 사용할 수 있습니다. </span></div>
</li>
</ul>
</li>
<li class="step stepexpand">옵션: <span class="cmd">다음 명령을 실행하고 컨테이너가 목록에 나타나지 않는지 확인하여 컨테이너가
제거되었는지 확인하십시오.*</span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ps -a</code></pre>
</li>
</ol>
</div>
<aside role="complementary" aria-labelledby="d75728e2237"></aside></article><article class="topic tutorial nested1" role="article" aria-labelledby="d75728e2384" lang="ko-kr" id="container_gettingstarted_tutorial"><h2 class="topictitle2" id="d75728e2384">튜토리얼: 단일 컨테이너 웹 애플리케이션 작성</h2>
<div class="body tutorialBody"><p class="shortdesc"><span class="keyword">IBM
Bluemix</span>는
퍼블릭 클라우드에서 Docker 컨테이너를 실행하는 기능을 제공합니다. 컨테이너를 사용하여 호스트 운영 체제와 독립적으로 실행되는 자체 포함,
보안 웹 앱을 배치하십시오. 컨테이너가 동일한 시스템 커널을 사용하기 때문에 컨테이너는 경량이고 많은 시스템 리소스를
필요로 하지 않고, 따라서 가상 머신보다 더욱 효율적으로 실행될 수 있습니다. 이 튜토리얼얼은 <span class="keyword">Bluemix</span>에서
Docker 컨테이너를 사용하여 메시징 웹 앱을 빌드하는 방법을 소개합니다.
프로세스에서 Dockerfile을 쓰고 Docker 이미지를 개인용 <span class="keyword">Bluemix</span> 이미지 레지스트리에 추가하며 컨테이너를
함께 연결합니다. </p>
<div class="section tutorialDesc"></div><section class="section learningObjectives tutorialLearningObjectives" role="region" aria-labelledby="d75728e2451"><h3 class="sectiontitle" id="d75728e2451">목표</h3>
<p>이 시나리오에서는 Let's Chat이라는 웹 앱을 <span class="keyword">Bluemix</span> 영역에 작성하게 됩니다. Let's Chat은 소규모
개발 팀을 위해 디자인된 온라인 메시징 앱입니다. <span class="keyword">Bluemix</span>를 사용하여 개인용 Docker 이미지 레지스트리를
관리하고 공용으로 액세스할 수 있게 웹 앱을 배치할 수 있습니다. </p>

<figure class="fignone" id="container_gettingstarted_tutorial__getting_started_tutorial"><figcaption>그림 1. 실행 중인 웹 앱의 아키텍처</figcaption><div class="image"><object width="480" data="images/getting_started_tutorial.svg"><img width="480" src="images/getting_started_tutorial.jpg" alt="Lets Chat 튜토리얼 다이어그램"></object></div></figure>

<div class="p">이 시나리오에서는 다음 태스크에 대한 지시사항을 제공합니다.<ul><li><span class="keyword">Bluemix</span> 계정 설정</li>
<li><span class="keyword">IBM
Bluemix Container Service</span> 명령행 인터페이스 설정</li>
<li>Dockerfile 작성</li>
<li>개인용 <span class="keyword">Bluemix</span> 이미지 레지스트리에 이미지 푸시</li>
<li>컨테이너 사이의 네트워크 연결을 작성하는 두 개의 컨테이너 링크</li>
<li>공용으로 액세스 가능한 컨테이너 빌드</li>
</ul>
</div>
</section>
<section class="section timeRequired tutorialTimeRequired" role="region" aria-labelledby="d75728e2502"><h3 class="sectiontitle" id="d75728e2502">소요 시간</h3>45분</section>
<section role="region" aria-labelledby="d75728e2506"><h3 class="sectiontitle" id="d75728e2506">대상</h3>
<p>이 튜토리얼은 <span class="keyword">Bluemix</span>의 Docker 컨테이너를 처음 접하거나
<span class="keyword">Bluemix</span> 퍼블릭 클라우드에서 실행 중인 앱을 배치하는 방법을 학습하려는 사용자들을 위한 것입니다. </p>
</section></div>
<article class="topic task tutorialLesson nested2" role="article" aria-labelledby="d75728e2520" lang="ko-kr" id="container_gettingstarted_tutorial_lesson_1"><h3 class="topictitle3" id="d75728e2520">학습 1: <span class="keyword">IBM
Bluemix Container Service</span> 설정</h3>
<div class="body taskbody"><p class="shortdesc">이 학습에서는 <span class="keyword">Bluemix</span> 계정을 작성하고, <span class="keyword">IBM
Bluemix Container Service</span> CLI를 설치하고, 사용자의 계정에 로그인하여
기본 IBM 이미지를 검토하게 됩니다. </p>
<ol class="steps"><li class="step stepexpand"><span class="cmd"><a href="https://console.ng.bluemix.net/registration/" rel="external" target="_blank" title="(새로운 탭이나 창으로 열기)"><span class="keyword">Bluemix</span>
등록 페이지</a>로 이동하여 계정을 작성하십시오. </span> 나중에 필요한 정보이므로 사용자 이름과 비밀번호를 기록해 놓으십시오.</li>
<li class="step stepexpand"><span class="cmd"><a href="https://github.com/cloudfoundry/cli/releases" rel="external" target="_blank" title="(새로운 탭이나 창으로 열기)">GitHub 저장소</a>에서 Cloud Foundry CLI 버전 <span class="ph">Cloud Foundry CLI 버전
<span class="ph" id="container_gettingstarted_tutorial_lesson_1__d28129e285">6.14.0</span> - 6.22.0</span>을 설치하십시오. </span> 운영 체제의 기본 위치에 Cloud Foundry CLI를 설치해야 합니다. 그렇지 않으면
PATH 환경 변수가 설치 디렉토리와 일치하지 않습니다.  <div class="steps note"><span class="notetitle">참고:</span> MacOS Sierra 사용자는 Cloud Foundry CLI 버전 6.22.0 이상을 설치해야 합니다. </div>


<div class="p">Cloud Foundry CLI가 제대로 설치되었는지 확인하거나, Cloud Foundry CLI를 이미
설치한 경우 설치된 버전을 확인하려면 다음 명령을
실행하십시오.<pre class="codeblock"><code>cf -v </code></pre>
</div>
</li>
<li class="step stepexpand"><span class="cmd">Docker 웹 사이트에서 <a href="https://www.docker.com/products/docker" rel="external" target="_blank" title="(새로운 탭이나 창으로 열기)">Docker 1.10.0 이상 설치</a>를 수행하십시오. </span></li>
<li class="step stepexpand"><span class="cmd">Docker 터미널을 여십시오. </span> Windows 또는 OS X용 Docker Toolbox를 사용하는 경우, Docker
Quickstart Terminal 프로그램을 여십시오. </li>
<li class="step stepexpand"><span class="cmd"><a href="https://clis.ng.bluemix.net/ui/home.html" rel="external" target="_blank" title="(새로운 탭이나 창으로 열기)"><span class="keyword">Bluemix</span> CLI</a>를 설치하십시오.</span></li>
<li class="step stepexpand"><span class="cmd" id="container_gettingstarted_tutorial_lesson_1__d28129e319"><span class="keyword">IBM
Bluemix Container Service</span> 플러그인을 설치하십시오. </span> <pre class="codeblock" id="container_gettingstarted_tutorial_lesson_1__d28129e329"><code><span class="ph">bx</span> plugin install IBM-Containers -r <span class="ph" data-hd-audience="yellow"><var class="keyword varname">Bluemix</var></span></code></pre>
 <div class="p">플러그인이 올바르게 설치되었는지 확인하려면 다음 명령을 실행하십시오. <pre class="codeblock"><code><span class="ph">bx</span> plugin list</code></pre>
</div>


<p>플러그인이 IBM-Containers로 결과에 표시됩니다. </p>
</li>
<li class="step stepexpand"><span class="cmd">이제 <span class="keyword">IBM
Bluemix Container Service</span> 플러그인을
설치했으므로 Docker 터미널에서 <samp class="ph codeph">docker run hello-world</samp>를 실행하십시오. </span> <pre class="codeblock"><code>docker run hello-world</code></pre>
 Docker 구성이 올바르게 설정되었는지 확인합니다. Docker는 로컬 이미지를
검색하므로, 이번이 명령을 처음으로 실행하는 경우라면 다음과 같은 메시지가 표시됩니다.

<pre class="pre screen"><code>Unable to find image 'hello-world:latest' locally</code></pre>
이미지를
Docker Hub, 이미지의 공용 저장소에서 가져오고 명령이 완료된 후에 사용자의 출력은 다음과 같이 표시됩니다.
<pre class="pre screen"><code>$ docker run hello-world

Hello from Docker.
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the <span class="q">"hello-world"</span> image from the Docker Hub.
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker Hub account:
 https://hub.docker.com

For more examples and ideas, visit:
 https://docs.docker.com/userguide/</code></pre>
 hello-world가 실행되지 않으면 <samp class="ph codeph">docker version</samp>을 실행하여
Docker가 올바르게 설치되었는지 식별하십시오. Windows 및 OS X 사용자는 사용자의 표준 터미널 창이 아니라 Docker Quickstart Terminal을 실행하고 있음을 확인합니다. </li>
<li class="step stepexpand">옵션: <span class="cmd"><span class="keyword">Bluemix</span>를 처음 사용하는 경우, API 엔드포인트를 지정하십시오. 
다음 코드 샘플은 <span class="keyword">Bluemix</span> 계정의 지역을 기본값으로 하지만
수동으로 지역을 변경할 수 있습니다. </span> <pre class="codeblock"><code>bx api https://api.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var></code></pre>
</li>
<li class="step stepexpand"><span class="cmd">이제 <span class="keyword">Bluemix</span> 계정에 로그인하십시오. </span> <span class="keyword">Bluemix</span> 계정을 작성했을 때 지정한 이메일과 비밀번호를 입력하십시오. 필요한 경우, 프롬프트에서 사용자가 선호하는 조직과 영역을 선택하십시오.
<pre class="codeblock"><code>bx login [-sso]</code></pre>
<span class="ph">싱글 사인온 매개변수 <span class="keyword option">-sso</span>는 연합 ID로 로그인할 때 필요합니다. 이 옵션이 사용되면 <a href="https://login.ng.bluemix.net/UAALoginServerWAR/passcode" rel="external" target="_blank" title="(새로운 탭이나 창으로 열기)">https://login.ng.bluemix.net/UAALoginServerWAR/passcode</a>를 열고 일회성 패스코드를 얻으십시오. <span class="keyword option">--sso</span> 옵션을 포함하지 않는 경우에는 다음의 하위 단계를 완료하십시오.</span><ol type="a" class="ol substeps"><li class="li substep"><span class="cmd"><span class="ph uicontrol">이메일</span>에 대해 <span class="keyword">Bluemix</span>의 IBM ID를 입력하십시오. </span></li>
<li class="li substep"><span class="cmd"><span class="ph uicontrol">비밀번호</span>에 대해 IBM ID의 비밀번호를 입력하십시오. </span> 사용자의 Bluemix 조직과 영역이 검색됩니다. </li>
<li class="li substep"><span class="cmd"><span class="keyword">Bluemix</span> 조직 중 하나를 표시하는 번호를 입력하십시오. </span></li>
<li class="li substep"><span class="cmd">기존 <span class="keyword">Bluemix</span> 영역 중 하나를 표시하는 번호를 입력하십시오. </span></li>
</ol>
</li>
<li class="step stepexpand"><span class="cmd">네임스페이스를 작성하십시오. </span> 조직의 네임스페이스는 <span class="keyword">Bluemix</span> 지역에 있는
컨테이너 이미지의 레지스트리에 고유한 ID입니다. 네임스페이스를 사용자의 <span class="keyword">Bluemix</span> 이미지 레지스트리를 IBM 퍼블릭 클라우드의 기타 모든 이미지
레지스트리와 구별하는 수단으로 여기십시오. <div class="steps note"><span class="notetitle">참고:</span> 사용자 또는 다른 사용자가 <span class="keyword">Bluemix</span> 조직에
로그인한 후 컨테이너를 작성한 경우 이미 네임스페이스가 있습니다. 다음 명령을 실행하여 해당 값을 찾을 수 있습니다. <pre class="codeblock"><code><samp class="ph codeph"><span class="ph">bx ic</span> namespace-get</samp></code></pre>
</div>
 <div class="p">다음은 네임스페이스 작성을 위한 몇 가지 팁입니다.
<ul><li>네임스페이스는 고유해야 합니다. IBM 퍼블릭 클라우드의 동일한 지역에 있는 다른 조직에서
사용할 수 없습니다.</li>
<li>네임스페이스는 4 - 30자일 수 있으며 소문자, 숫자 또는 밑줄(_)만 포함할 수 있습니다.</li>
<li>네임스페이스를 짧게 유지하십시오. 명령행을 사용하는 경우, 이미지의 태그를 지정하고 푸시하는 작업의 일부로 자주 네임스페이스를 입력하게 됩니다. </li>
</ul>
</div>


<p>다음 명령에서 <var class="keyword varname">your_registry_name_here</var>을 선택한 네임스페이스로 대체하십시오. </p>
 <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> namespace-set <var class="keyword varname">your_registry_name_here</var></code></pre>
</li>
<li class="step stepexpand">옵션: <span class="cmd">네임스페이스에 대한 변수를 설정하십시오. </span> 이 튜토리얼 전체에서 예제 명령에는 사용자의 네임스페이스를 두는 위치를 표시하는 <samp class="ph codeph">$your_namespace</samp>
문자열이 포함됩니다. 수동으로 해당 명령을 편집하지 않으려면 터미널에서 변수를 작성하십시오.  <pre class="codeblock"><code>your_namespace=<var class="keyword varname">your_registry_name_here</var></code></pre>
 사용자의 네임스페이스로 <samp class="ph codeph">ljenkins1</samp>을 사용하는 예 <pre class="pre screen"><code>$ your_namespace=<var class="keyword varname">ljenkins1</var></code></pre>
</li>
<li class="step stepexpand"><span class="cmd"><span class="keyword">IBM
Bluemix Container Service</span>를 초기화하십시오. </span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> init</code></pre>
</li>
<li class="step stepexpand"><span class="cmd"><span class="keyword">IBM
Bluemix Container Service</span>에 로그인했으면 사용자에게 사용 가능한 기본 이미지를
확인하십시오. </span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> images</code></pre>


<pre class="pre screen"><code>$ <span class="ph"><samp class="ph codeph">bx ic</samp></span> images
REPOSITORY                                        TAG                 IMAGE ID            CREATED             SIZE
registry.ng.bluemix.net/ibm-mobilefirst-starter   latest              d61c09fd0af7        4 weeks ago         510.2 MB
registry.ng.bluemix.net/ibm-node-strong-pm        latest              322b9ca7b2dc        2 weeks ago         255.5 MB
registry.ng.bluemix.net/ibmliberty                latest              33fdda9431c7        2 days ago          292.5 MB
registry.ng.bluemix.net/ibmnode                   latest              c33c25d4af3b        2 days ago          187.8 MB
registry.ng.bluemix.net/ibmnode                   v4                  c33c25d4af3b        2 days ago          187.8 MB
registry.ng.bluemix.net/ibmnode                   v1.1                ef3425f90e1e        2 days ago          175.3 MB
registry.ng.bluemix.net/ibmnode                   v1.2                c5546bf5e891        2 days ago          183.6 MB</code></pre>


<div class="tablenoborder"><table summary="" id="container_gettingstarted_tutorial_lesson_1__table_lqp_hkm_2v" class="defaultstyle"><caption><span class="tablecap">표 3. 이미지 및 컨테이너에 대해 자세히 보기</span></caption><thead><tr><th colspan="2" id="d75728e2905" class="thleft"><span class="ph"><img src="images/idea.png" alt="이 아이콘은 이 태스크 단계에 대해 학습할 정보가 더 있음을 나타냅니다."></span> 이미지 및 컨테이너에 대한
자세한 정보</th>
</tr>
</thead>
<tbody><tr><td style="width: NaN%" headers="d75728e2905 ">이미지 vs. 컨테이너</td>
<td style="width: NaN%" headers="d75728e2905 "><p> 이미지와 컨테이너의 차이점은 무엇입니까? 기본적으로 이미지는 정의된 계층과 명령의
읽기 전용 스냅샷입니다. 이미지를 실행한 후에만 컨테이너가 됩니다. 이 프로세스의 이점 중 하나는 컨테이너에 어떤 변경사항을 작성하더라도
이미지 스냅샷은 변경되지 않은 상태를 유지합니다. 단일 컨테이너는 설계에서 임시 프로세스로 의도한 것입니다. 컨테이너에서 지속되어야 하는
구성 또는 데이터는 지속적 볼륨에 저장되거나 이미지로 작성되어야 합니다. <a href="https://docs.docker.com/glossary/?term=image" rel="external" target="_blank" title="(새로운 탭이나 창으로 열기)">이미지의 정의</a>는 Docker 용어집을 참조하십시오. </p>
</td>
</tr>
<tr><td style="width: NaN%" headers="d75728e2905 ">IBM 이미지</td>
<td style="width: NaN%" headers="d75728e2905 "><p>이 튜토리얼에서는 Docker Hub의 이미지를 사용합니다. 그러나 IBM에서는 자체 이미지 빌드에 사용할 수 있거나
컨테이너 실행에 사용할 수 있는 네 개의 해당 이미지 <span class="q">"스냅샷"</span>도 제공합니다. 여기에서 <a href="container_images_adding_ov.html#container_images_adding_ov" title="컨테이너 이미지는 작성하는 모든 컨테이너의 기초가 됩니다. 이미지는 빌드 아티팩트(예: 앱, 앱의 구성 및 이의 종속 항목) 및 이미지를 빌드하는 지시사항이 포함된 파일인 Dockerfile에서 작성됩니다. 컨테이너 이미지를 실행 파일(.exe 또는 .bin)로서 생각하십시오. 실행 가능 앱 파일을 실행하는 즉시 앱의 인스턴스가 작성됩니다. 컨테이너를 실행하면 이미지에서 컨테이너 인스턴스가 작성됩니다.">IBM 이미지</a>에 관하여 읽으십시오.</p>
</td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
<div class="section result"><p>축하합니다! Bluemix 계정을 작성했으며, CLI 플러그인을 설치했고 웹 앱 빌드를 위해 사용자에게 사용 가능한
이미지를 보기 위해 로그인했습니다. </p>

<p>사용자 레지스트리에 이미지를 추가하려면 다음 학습을 계속하십시오. </p>
</div></div>
</article><article class="topic task tutorialLesson nested2" role="article" aria-labelledby="d75728e2948" lang="ko-kr" id="container_gettingstarted_tutorial_lesson_2"><h3 class="topictitle3" id="d75728e2948">학습 2: 개인용 <span class="keyword">Bluemix</span> 이미지 레지스트리에 이미지 추가</h3>
<div class="body taskbody"><p class="shortdesc">이 학습에서는 두 가지 방법(Docker Hub에서 이미지 복사, Dockerfile 작성)을 사용하여
개인용 레지스트리에 이미지를 추가합니다. 사용자 고유의 Dockerfile을 작성하면 사용자 고유의 명령을
이미지에 추가할 수 있습니다. 따라서 그 이미지에서 실행된 모든 컨테이너에 해당 명령이 포함됩니다.
컨테이너의 이점 중 하나는 이러한 이미지가 조직의 모든 사람들이 지속적 운영 환경으로
컨테이너를 빌드할 수 있도록 소스 제어를 유지보수하는 데 도움이 된다는 점입니다. </p>
<div class="section context">다음 이미지가 이 학습에서 사용됩니다. Docker Hub에서 이미지 및 기타 정보에 대해 Dockerfile을
검토할 수 있습니다.<ul><li><a href="https://hub.docker.com/_/mongo/" rel="external" target="_blank" title="(새로운 탭이나 창으로 열기)">MongoDB</a></li>
<li><a href="https://hub.docker.com/r/sdelements/lets-chat/" rel="external" target="_blank" title="(새로운 탭이나 창으로 열기)">Let's Chat</a></li>
</ul>
</div><ol class="steps"><li class="step stepexpand"><span class="cmd">MongoDB 이미지를 Docker Hub에서 개인용 <span class="keyword">Bluemix</span> 이미지 레지스트리에 복사하십시오. </span> 데이터를 저장하는 데 MongoDB 이미지를 사용합니다. MongoDB 컨테이너를 데이터 저장에 사용할 수 있더라도, 컨테이너가 제거될 때 컨테이너에 작성된 데이터도 유실됩니다. 컨테이너에 작성된 데이터를 지속시키려면 컨테이너를 실행할 때 볼륨을 마운트해야 합니다.  <p>변수 대체를 설정하지 않은 경우 학습 1에서 작성한 네임스페이스로 <samp class="ph codeph"><var class="keyword varname">$your_namespace</var></samp>를
잊지 않고 대체하십시오. 사용자의 네임스페이스가 무엇인지 확인해야 하는 경우, <samp class="ph codeph"><span class="ph"><samp class="ph codeph">bx ic</samp></span> namespace get</samp>을 실행하십시오. </p>
 <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> cpi <var class="keyword varname">mongo</var> registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/<var class="keyword varname">$your_namespace</var>/<var class="keyword varname">mongo</var></code></pre>
 초기 출력 코드는 다음 예제와
유사합니다.
<pre class="pre screen"><code>$ <span class="ph"><samp class="ph codeph">bx ic</samp></span> cpi mongo registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/<var class="keyword varname">$your_namespace</var>/<var class="keyword varname">mongo</var>
Sending build context to Docker daemon 2.048 kB
Step 1 : FROM mongo
 ---&gt; 32427ae49eff
Successfully built 32427ae49eff
The push refers to a repository [registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/<var class="keyword varname">$your_namespace</var>/<var class="keyword varname">mongo</var>] (len: 1)</code></pre>
 백그라운드에서 Docker Hub의 mongo 이미지를 사용자의 Bluemix 이미지 레지스트리에
복사 중입니다. <samp class="ph codeph">cpi</samp> 명령이 완료되는 데 몇 분이 걸릴 수 있으며 완료되면
전체 출력이 다음 예제와 같이 표시됩니다.

<pre class="pre screen"><code>$ <span class="ph"><samp class="ph codeph">bx ic</samp></span> cpi mongo registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/<var class="keyword varname">$your_namespace</var>/<var class="keyword varname">mongo</var>
Sending build context to Docker daemon 2.048 kB
Step 1 : FROM mongo
 ---&gt; 32427ae49eff
Successfully built 32427ae49eff
The push refers to a repository [registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/<var class="keyword varname">$your_namespace</var>/<var class="keyword varname">mongo</var>] (len: 1)
32427ae49eff: Pushed
424ec4bd7fc4: Pushed
9e3490ec0722: Pushed
166aa7bca9c1: Pushed
c79deeebd6f0: Pushed
c181e50c0e8b: Pushed
438e27bd44bf: Pushed
af6f43fa45bb: Pushed
605e5767a4ac: Pushed
33e8076f6b28: Pushed
e63969171eec: Pushed
latest: digest: sha256:ab092d78d331337cf6cf0ceeda28489f5e154b1403ca1220e9de6b417
b7cfb95 size: 32158</code></pre>
 <div class="tablenoborder"><table summary="" id="container_gettingstarted_tutorial_lesson_2__table_sdf_nkm_2v" class="defaultstyle"><thead><tr><th colspan="2" id="d75728e3116" class="thleft"><span class="ph"><img src="images/idea.png" alt="이 아이콘은 이 태스크 단계에 대해 학습할 정보가 더 있음을 나타냅니다."></span> 이 명령의 컴포넌트 이해</th>
</tr>
</thead>
<tbody><tr><td style="width: NaN%" headers="d75728e3116 "><samp class="ph codeph">cpi</samp></td>
<td style="width: NaN%" headers="d75728e3116 ">복사 명령어입니다. </td>
</tr>
<tr><td style="width: NaN%" headers="d75728e3116 "><samp class="ph codeph">mongo</samp></td>
<td style="width: NaN%" headers="d75728e3116 ">소스 저장소와 이름입니다. 이런 경우, 이미지의 이름이 <var class="keyword varname">mongo</var>이고 이미지가 Docker Hub에 위치하기 때문에
추가적 저장소 정의가 필요하지 않습니다. </td>
</tr>
<tr><td style="width: NaN%" headers="d75728e3116 "><samp class="ph codeph">registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/<var class="keyword varname">$your_namespace</var>/<var class="keyword varname">mongo</var></samp></td>
<td style="width: NaN%" headers="d75728e3116 ">대상 레지스트리 경로이며 사용자의 고유 네임스페이스와 대상 이미지의 이름을
포함합니다. 이 예의 경우 이미지의 이름을 <var class="keyword varname">mongo</var>로 유지하고
있지만 개인용 레지스트리에서 이미지의 이름을 선택할 수 있습니다. CLI에서
이 이미지에 대한 작업을 할 때 전체 경로 <samp class="ph codeph">registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/<var class="keyword varname">$your_namespace</var>/<var class="keyword varname">mongo</var></samp>로 이미지를 지정합니다. </td>
</tr>
</tbody>
</table>
</div>
</li>
<li class="step stepexpand"><span class="cmd">작성하고 사용자의 Dockerfile을 위한 새 로컬 폴더로 이동하십시오. </span> <samp class="ph codeph">cpi</samp> 명령을 통해 레지스트리에 이미지를 추가했으며
Dockerfile에서 다른 이미지를 작성하려고 합니다. Dockerfile은 사용자가 로컬에서 이미지를 빌드할 수 있도록 하며,
사용자의 웹 앱에 필요한 추가 명령 또는 변수를 추가할 수 있도록 합니다. 이러한 명령 중 일부는 컨테이너 빌드 중에 추가될 수 있지만,
이를 통해 동일한 이미지의 다중 버전으로 단편화를 작성할 수 있습니다. Dockerfile에 명령을 추가하면
이 이미지에서 빌드된 모든 컨테이너에 해당 명령이 있음이 확실하게 됩니다.  <pre class="codeblock"><code>mkdir wrapper &amp;&amp; cd wrapper</code></pre>
</li>
<li class="step stepexpand"><span class="cmd"><span class="ph filepath">wrapper</span> 폴더 내에 Dockerfile을 작성하십시오. </span> 이 명령은 Dockerfile을 작성하고 지정된 <var class="keyword varname">FROM</var> 명령을 추가하며,
모든 Dockerfile에 필요합니다. <var class="keyword varname">FROM</var>은 상위 이미지가 어떤 것일지 설명합니다.
이 경우, 상위로 <var class="keyword varname">lets-chat</var> 이미지를 사용합니다. <pre class="codeblock"><code>echo <span class="q">"FROM sdelements/lets-chat:latest"</span> &gt; Dockerfile</code></pre>
</li>
<li class="step stepexpand"><span class="cmd">현재 디렉토리에 파일을 나열하여 Dockerfile이 작성되었음을 확인하십시오. </span> <pre class="codeblock"><code>ls</code></pre>
</li>
<li class="step stepexpand"><span class="cmd">네트워크 지연 명령을 사용자의 Dockerfile에 추가하십시오. </span> lets-chat 컨테이너가 시작될 때 <span class="keyword">IBM
Bluemix Container Service</span>는
사설 컨테이너 네트워크를 설정하며 사설 IP 주소를 컨테이너에 지정합니다. 
lets-chat 앱에서는 앱이 시작되는 시점에 활성 네트워크 연결이 필요합니다. 네트워크 지연을 추가하면 앱이 시작되기 전에
<span class="keyword">IBM
Bluemix Container Service</span> 네트워킹이 완료될 수 있는 충분한 시간이 보장됩니다.  <pre class="codeblock"><code>echo <span class="q">"CMD (sleep 60; npm start)"</span> &gt;&gt; Dockerfile</code></pre>
</li>
<li class="step stepexpand"><span class="cmd">사용자의 이미지를 빌드하고 태그를 지정하십시오. </span> 명령의 끝에 <samp class="ph codeph">.</samp>를 빠트리지 마십시오! 마침표는 Docker가 필요한 Dockerfile에 대한 현재 로컬 폴더의 내부를 보게 합니다.  <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> build -t registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/<var class="keyword varname">$your_namespace</var>/lets-chat .</code></pre>
</li>
<li class="step stepexpand"><span class="cmd"><var class="keyword varname">mongo</var> 이미지와 <var class="keyword varname">lets-chat</var> 이미지가
<span class="keyword">Bluemix</span> 이미지 레지스트리에
있는지 확인하십시오. </span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> images</code></pre>


<pre class="pre screen"><code>$ <span class="ph"><samp class="ph codeph">bx ic</samp></span> images
REPOSITORY                                                  TAG                 IMAGE ID            CREATED             SIZE
registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/<var class="keyword varname">$your_namespace</var>/<var class="keyword varname">mongo</var>                          latest              8de059ee71fc        2 minutes ago         317.4 MB
registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/<var class="keyword varname">$your_namespace</var>/<var class="keyword varname">lets-chat </var>                      latest              d4de00f58363        5 minutes ago          0 B
registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/ibm-node-strong-pm                  latest              322b9ca7b2dc        2 weeks ago         616.4 MB
registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/ibmliberty                          latest              6595ea483bf5        2 weeks ago         552.8 MB
registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/ibmnode                             latest              b2c351248227        2 weeks ago         472.4 MB
registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/ibmnode                             v4                  b2c351248227        2 weeks ago         472.4 MB
registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/ibmnode                             v1.1                7d11220193d6        2 weeks ago         449.2 MB
registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/ibmnode                             v1.2                84efce0c747b        2 weeks ago         465.2 MB</code></pre>
</li>
</ol>
<div class="section result"><p>이제 필요한 이미지가 개인용 <span class="keyword">Bluemix</span> 이미지 레지스트리에 있습니다. Dockerfile을 작성했을 뿐 아니라
Docker Hub 이미지를 복사하고 새 이미지를 빌드하여 해당 이미지를
<span class="keyword">Bluemix</span> 이미지 레지스트리에 푸시했습니다. </p>

<p>다음 학습에서는 컨테이너를 작성하고, 함께 링크해서 사용자의 웹 앱을 배치하게 됩니다. </p>
</div></div>
</article><article class="topic task tutorialLesson nested2" role="article" aria-labelledby="d75728e3327" lang="ko-kr" id="container_gettingstarted_tutorial_lesson_3"><h3 class="topictitle3" id="d75728e3327">학습 3: 컨테이너 빌드 및 배치</h3>
<div class="body taskbody"><p class="shortdesc"><span class="keyword">Bluemix</span> 이미지 레지스트리에 Let's Chat 메시징 웹 앱을 배치하는 데
필요한 이미지가 있습니다. 이 학습에서는 컨테이너를 빌드하고 함께 연결해서
공인 IP 주소를 앱에 지정합니다. </p>
<ol class="steps"><li class="step stepexpand"><span class="cmd">mongo 이미지에서 컨테이너를 실행하십시오. </span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> run --name <var class="keyword varname">lc-mongo</var> -p <var class="keyword varname">27017</var> -m <var class="keyword varname">128</var> registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/<var class="keyword varname">$your_namespace</var>/mongo</code></pre>
 <div class="tablenoborder"><table summary="" id="container_gettingstarted_tutorial_lesson_3__table_lqp_hkm_2v" class="defaultstyle"><thead><tr><th colspan="2" id="d75728e3413" class="thleft"><span class="ph"><img src="images/idea.png" alt="이 아이콘은 이 태스크 단계에 대해 학습할 정보가 더 있음을 나타냅니다."></span> 이 명령의 컴포넌트 이해</th>
</tr>
</thead>
<tbody><tr><td style="width: 22.22222222222222%" headers="d75728e3413 ">run</td>
<td style="width: 77.77777777777779%" headers="d75728e3413 "><p> 지정 이미지로에서 컨테이너를 작성하는 실행 명령어입니다. </p>
</td>
</tr>
<tr><td style="width: 22.22222222222222%" headers="d75728e3413 ">--name</td>
<td style="width: 77.77777777777779%" headers="d75728e3413 ">컨테이너의 이름을 정의합니다. 이 경우, 컨테이너를 <var class="keyword varname">lc-mongo</var>라고 이름을 지정했습니다. </td>
</tr>
<tr><td style="width: 22.22222222222222%" headers="d75728e3413 ">-p</td>
<td style="width: 77.77777777777779%" headers="d75728e3413 "><span class="ph">인터넷에서 앱에 액세스할 수 있게 하려면 공용 포트를 노출시켜야 합니다.
공용 포트를 노출할 때 노출된 포트에서만 공개 데이터를 전송 및 수신할 수 있게 하는 컨테이너에 대한 공용 네트워크 보안 그룹을 작성합니다. 기타 공용 포트는 닫히고 인터넷에서 앱에 액세스하는 데 사용할 수 없습니다. 여러 번
<span class="keyword option">-p</span> 옵션을 사용하여 여러 포트를 포함할 수 있습니다. 포트는 맵핑되거나
전달될 수 없습니다.포트를 노출시키지 않으면, 컨테이너는 사설 컨테이너 네트워크에서만 액세스 가능합니다. 지정된 사설 IP 주소를 사용하여
사설 네트워크에 있는 컨테이너와 통신할 수 있습니다. </span> 이 경우,
해당 포트가 Dockerfile에서 지정되었기 때문에 포트 27017을 노출합니다. </td>
</tr>
<tr><td style="width: 22.22222222222222%" headers="d75728e3413 ">-m</td>
<td style="width: 77.77777777777779%" headers="d75728e3413 "><span class="ph">컨테이너의 메모리 한계(MB)를 입력하십시오. 메모리 한계는
런타임 중에 컨테이너가 컴퓨팅 호스트에서 얻는 메모리와 디스크 공간의 최대 크기를
정의하는 컨테이너 크기의 일부입니다. 컨테이너 크기가 지정된 후에는 값을 변경할 수 없습니다.</span></td>
</tr>
</tbody>
</table>
</div>
</li>
<li class="step stepexpand"><span class="cmd">컨테이너가 실행 중인지 확인하십시오. </span> 다음 단계로 계속하기 전에 상태가 실행 중으로 업데이트되도록 기다리십시오. 필요한 경우,
컨테이너 상태가 실행 중이 될 때까지 <samp class="ph codeph"><span class="ph"><samp class="ph codeph">bx ic</samp></span> ps</samp>를 실행할 수 있습니다.  <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ps</code></pre>


<pre class="pre screen"><code>$<span class="ph"><samp class="ph codeph">bx ic</samp></span> ps
CONTAINER ID        IMAGE                                           COMMAND             CREATED             STATUS                PORTS               NAMES
9f73abc2-9a1        registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/<var class="keyword varname">$your_namespace</var>/<var class="keyword varname">mongo</var>:latest       <span class="q">""</span>                  40 seconds ago          Running 5 seconds ago    27017/tcp           lc-mongo</code></pre>
</li>
<li class="step stepexpand"><span class="cmd"><var class="keyword varname">mongo</var> 컨테이너가 실행 중 상태가 된 후 <var class="keyword varname">lets-chat</var>
컨테이너를 실행하십시오.</span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> run --name <var class="keyword varname">lets-chat</var> --link lc-mongo:mongo -p <var class="keyword varname">8080</var> -m <var class="keyword varname">128</var> registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/<var class="keyword varname">$your_namespace</var>/<var class="keyword varname">lets-chat</var></code></pre>
 <div class="tablenoborder"><table summary="" id="container_gettingstarted_tutorial_lesson_3__table_o22_ttv_4x" class="defaultstyle"><thead><tr><th colspan="2" id="d75728e3522" class="thleft"><span class="ph"><img src="images/idea.png" alt="이 아이콘은 이 태스크 단계에 대해 학습할 정보가 더 있음을 나타냅니다."></span> 이 명령의 컴포넌트 이해</th>
</tr>
</thead>
<tbody><tr><td style="width: 22.22222222222222%" headers="d75728e3522 ">--link</td>
<td style="width: 77.77777777777779%" headers="d75728e3522 "><p><samp class="ph codeph">lc-mongo</samp>와 같은 데이터베이스 컨테이너를 다른 컨테이너에 링크하는 것이
<samp class="ph codeph">--link</samp>의 일반적인 사용 중 하나입니다. <samp class="ph codeph">--link</samp> 플래그는 <var class="keyword varname">lc-mongo</var> 컨테이너에 대해 <var class="keyword varname">lets-chat</var>
컨테이너에 호스트 항목을 작성하며, 이는 컨테이너가 서로 통신할 수 있게 허용합니다. </p>
</td>
</tr>
</tbody>
</table>
</div>
</li>
<li class="step stepexpand"><span class="cmd">사용자의 컨테이너를 보십시오. </span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ps</code></pre>


<pre class="pre screen"><code>$<span class="ph"><samp class="ph codeph">bx ic</samp></span> ps
CONTAINER ID        IMAGE                                           COMMAND             CREATED             STATUS                  PORTS                         NAMES
68f6536a-82f        registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/<var class="keyword varname">$your_namespace</var>/<var class="keyword varname">lets-chat</var>:latest   <span class="q">""</span>                  3 days ago          Running 6 seconds ago   8080/tcp                      <var class="keyword varname">lets-chat</var>
9f73abc2-9a1        registry.<var class="keyword varname" data-hd-keyref="DomainName">domain_name</var>/<var class="keyword varname">$your_namespace</var>/<var class="keyword varname">mongo</var>:latest       <span class="q">""</span>                  3 days ago          Running 3 days ago      27017/tcp                     <var class="keyword varname">lc-mongo</var></code></pre>
</li>
<li class="step stepexpand"><span class="cmd">사용 가능한 IP 주소를 나열하십시오. </span> IP 주소를 바인딩하면 사용자의 단일 컨테이너 웹 앱이 인터넷을 통해 액세스 가능하게 됩니다.  <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ips</code></pre>
</li>
<li class="step stepexpand">옵션: <span class="cmd">IP 주소가 나열되지 않으면 IP 주소를 요청하십시오. </span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ip-request</code></pre>
</li>
<li class="step stepexpand"><span class="cmd">사용 가능한 IP 주소를 선택하고 <var class="keyword varname">lets-chat</var> 컨테이너에 바인드하십시오. </span> 모든 IP 주소가 이미 바인드된 경우에는 먼저 <a href="container_cli_reference_cfic.html#container_cli_reference_cfic__ip_unbind">IP 주소 바인드 해제</a>를 수행해야 한다는 점을 참고하십시오.Bluemix 조직에서 사용할 수 있는 IP 주소로 이 예제 IP 주소를 대체하십시오.  <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ip-bind <var class="keyword varname">192.0.2.100</var> lets-chat</code></pre>
</li>
<li class="step stepexpand"><span class="cmd">IP 주소의 바인딩이 완료될 때까지 대기하십시오. </span> <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> inspect lets-chat</code></pre>
IP 주소가 컨테이너에 바인드되는 순간, 이는 CLI 출력의
<span class="ph uicontrol">네트워크</span> 섹션에서 <span class="ph uicontrol">PublicIpAdress</span>로 나열됩니다.
<pre class="pre screen"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> inspect lets-chat
...
<span class="q">"PortMapping"</span>: null,
<span class="q">"Ports"</span>: {
    <span class="q">"8080/tcp"</span>: [
      {
         <span class="q">"HostIp"</span>: <span class="q">"192.0.2.100"</span>,
         <span class="q">"HostPort"</span>: <span class="q">"8080"</span>
      }
    ]
 },
 <span class="q">"PublicIpAddress"</span>: <span class="q">"192.0.2.100"</span>
...</code></pre>
</li>
<li class="step stepexpand"><span class="cmd">구동되어 실행 중인 웹 앱을 가서 보십시오! 포트를 포함하여 바인드된 공인 IP 주소를 웹 브라우저에 붙여넣기하십시오. </span> <pre class="codeblock"><code>http://<var class="keyword varname">192.0.2.100</var>:8080</code></pre>
 <p><img src="images/lets-chat_screenshot.jpg" alt="Let's Chat 웹 앱에 로그인하십시오."></p>
</li>
<li class="step stepexpand">옵션: <span class="cmd">Let's Chat에 계정을 작성하고 로그인하여 IBM Containers에서 실행 중인 사용자의 웹 앱을 확인하십시오!</span> <p><img src="images/lets-chat-room.png" alt="lets-chat 룸"></p>
</li>
<li class="step stepexpand">옵션: <span class="cmd">컨테이너를 중지하십시오. </span> 사용자의 컨테이너가 리소스를 소모하지 않게 하려면 컨테이너를 중지하고 제거할 수 있습니다.  <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> stop <var class="keyword varname">lets-chat</var> <var class="keyword varname">lc-mongo</var></code></pre>


<pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> rm <var class="keyword varname">lets-chat</var> <var class="keyword varname">lc-mongo</var></code></pre>
</li>
</ol>
<div class="section result" id="container_gettingstarted_tutorial_lesson_3__quiz">학습한 내용을 확인해 보십시오! 이제 튜토리얼을 완료하였으니 <a href="http://bluemix-quizzes.mybluemix.net/containers/single_containers_gettingstarted_tutorial/quiz.php" rel="external" target="_blank" title="(새로운 탭이나 창으로 열기)">퀴즈를 풀면서 학습한 내용을 확인해 보십시오</a>.</div><div class="section postreq"><div class="p"> 다음에는 무엇을 하시겠습니까? 이 튜토리얼에 적용할 수 있는 많은 기타 <span class="keyword">IBM
Bluemix Container Service</span>
기능이 있습니다. <ul><li><a href="container_ha.html#container_group_ui" title="Bluemix GUI에서 확장 가능한 그룹 컨테이너를 작성하고 배치합니다. 컨테이너 그룹에는 동일한 이미지를 실행하는 두 개 이상의 컨테이너가 포함됩니다. 확장성 및 신뢰성이 요구되는 워크로드가 포함된 장기적 서비스를 실행하거나 필요한 스케일로 테스트할 때 컨테이너 그룹을 사용하십시오.">고가용성 컨테이너 그룹</a>으로 단일 컨테이너를 대체하고 사용 불가능한 컨테이너를 자동으로 대체하는 자동 복구를 사용으로 설정하십시오. </li>
<li><a href="container_volumes_ov.html#container_volumes_ui" title="볼륨은 앱이 작성하는 데이터 또는 앱이 실행해야 하는 파일의 지속적 스토리지 위치입니다. Bluemix GUI에서 컨테이너의 볼륨을 작성할 수 있습니다.">스토리지 볼륨</a>을 작성하고 사용자의 Mongo 및 lets-chat 컨테이너에 마운트하여 컨테이너 데이터가 컨테이너 재시작 시에도 유지되고 사용자의 사설 네트워크에 있는 다중 컨테이너에서 액세스할 수 있게 하십시오. </li>
<li>잠재적인 취약점에 대해 사용자의 레지스트리에서 이미지를 스캔하여 사용자의 조직을 안전하게
유지할 수 있도록 하는 <a href="va/va_index.html#va_reviewing">Vulnerability Advisor</a>로 이미지를 검토하십시오. </li>
</ul>
… 그 밖에도 많은 기능이 있습니다. 지금 시작하십시오.</div>
</div></div>
</article></article><article class="topic tutorial tutorialIntro nested1" role="article" aria-labelledby="d75728e3772" lang="ko-kr" id="container_compose_intro"><h2 class="topictitle2" id="d75728e3772">튜토리얼: Docker Compose 및 <span class="keyword">IBM
Bluemix Container Service</span>를 사용하여 다중 컨테이너 배치 작성</h2>
<div class="body  tutorialIntroBody"><p class="shortdesc">데이터베이스, 서비스 및 캐시 등의 다중 컴포넌트가 있는 앱의 경우에는
모든 컨테이너를 함께 시작하고 종료하도록 조정하는 것이 어려울 수 있습니다.
이 튜토리얼에서는 하나의 Docker Compose 명령을 사용하여 마이크로서비스 아키텍처에서 다중 컨테이너 배치로
앱을 배치 및 실행하는 방법을 알아봅니다. 이 시스템의 일부인 각 컨테이너는 Docker Compose 서비스 정의를 기반으로 하며
자체 격리된 환경에서 실행됩니다. </p>
<section class="section learningObjectives tutorialLearningObjectives" role="region" aria-labelledby="d75728e3834"><h3 class="sectiontitle" id="d75728e3834">시나리오</h3>이 튜토리얼은 소프트웨어 개발자가 Docker Compose 및
<span class="keyword">IBM
Bluemix Container Service</span>를 사용하여 수신 사용자 트래픽의
밸런스를 조정하는 nginx 로드 밸런서와 Mongo 데이터베이스에 연결되는 Lets-Chat 웹 앱을
실행하는 다중 컨테이너 배치를 배치할 수 있는 방법을 소개합니다. <div class="p"><figure class="fignone" id="container_compose_intro__fig_compose"><figcaption>그림 2. 다중 컨테이너 Lets-Chat 앱의 대상 시나리오</figcaption><a href="../api/content/containers/images/container_compose_tutorial.png" rel="external" target="_blank" title="(새로운 탭이나 창으로 열기)"><div class="image"><img src="images/container_compose_tutorial.png" width="700" alt="다중 컨테이너 Lets-Chat 앱의 대상 시나리오"></div></a></figure>
</div>
<div class="p">학습은 다음과 같이 구성됩니다.<dl><dt class="dlterm"><a href="container_single_ui.html#container_compose_config" title="먼저, docker-compose.yml이라는 YAML 파일에서 다중 컨테이너 배치의 각 서비스를 구성합니다. 각 서비스에 대해 이미지, 노출할 포트 및 시스템의 다른 서비스에 대한 링크를 지정합니다.">학습
1: 다중 컨테이너 배치 구성</a></dt>
<dd>구성 파일 <span class="ph filepath">docker-compose.yml</span>에서 Mongo 데이터베이스 및 Lets-Chat 웹 앱에 대한 서비스를 정의합니다. </dd>
<dt class="dlterm"><a href="container_single_ui.html#container_compose_run" title="다음으로 다중 컨테이너 배치를 배치하고 실행합니다. Lets-Chat 및 Mongo 데이터베이스 컨테이너를 개별적으로 작성해서 시작하고 수동으로 함께 링크하는 대신에 docker-compose.yml 파일의 서비스 정의를 기반으로 사용자의 컨테이너를 작성하는 단일 Docker Compose 명령을 사용합니다.">학습 2: 다중 컨테이너 배치 실행</a></dt>
<dd>다중 컨테이너 배치에서 Lets-Chat 앱을 실행하고 하나의 Docker Compose 명령을 사용하여
인터넷에서 해당 앱에 액세스합니다. </dd>
<dt class="dlterm"><a href="container_single_ui.html#container_compose_scale" title="다중 컨테이너 배치가 현재 실행 중인 상태로 Lets-Chat 컨테이너 인스턴스의 수를 늘려 앱을 보다 안정적으로 만듭니다.">학습 3:
다중 컨테이너 배치 스케일링</a></dt>
<dd>컨테이너 인스턴스의 수를 늘려서 Lets-Chat 웹 앱을 더욱 안정적으로 만듭니다. </dd>
<dt class="dlterm"><a href="container_single_ui.html#container_compose_loadbalance" title="높은 워크로드에 대응하기 위해 Lets-Chat 컨테이너 인스턴스 간 수신 사용자 트래픽의 밸런스를 조절하는 다중 컨테이너 배치에 nginx 로드 밸런서를 추가합니다.">학습 4:
다중 컨테이너 배치에 로드 밸런서 추가</a></dt>
<dd>Lets-Chat 컨테이너 인스턴스 간 수신 네트워크 트래픽의 밸런스를 조정하는 다중 컨테이너
배치에 nginx 로드 밸런서를 추가하여 업무 시간 동안의 높은 워크로드에 대응합니다. </dd>
<dt class="dlterm"><a href="container_single_ui.html#container_compose_remove" title="최종 단계로서 다중 컨테이너 배치를 제거하여 사용된 리소스를 릴리스하고 할당량의 사용을 최대화합니다.">학습
5: 다중 컨테이너 배치 제거</a></dt>
<dd>다중 컨테이너 배치를 삭제하여 사용된 리소스를 릴리스하고 할당량의 사용을
최대화합니다. </dd>
</dl>
<div class="note tip"><span class="tiptitle">팁:</span> <span class="keyword">IBM
Bluemix Container Service</span>에 익숙하지 않은 경우, <a href="container_single_ui.html#container_gettingstarted_tutorial" title="IBM Bluemix는 퍼블릭 클라우드에서 Docker 컨테이너를 실행하는 기능을 제공합니다. 컨테이너를 사용하여 호스트 운영 체제와 독립적으로 실행되는 자체 포함, 보안 웹 앱을 배치하십시오. 컨테이너가 동일한 시스템 커널을 사용하기 때문에 컨테이너는 경량이고 많은 시스템 리소스를 필요로 하지 않고, 따라서 가상 머신보다 더욱 효율적으로 실행될 수 있습니다. 이 튜토리얼얼은 Bluemix에서 Docker 컨테이너를 사용하여 메시징 웹 앱을 빌드하는 방법을 소개합니다. 프로세스에서 Dockerfile을 쓰고 Docker 이미지를 개인용 Bluemix 이미지 레지스트리에 추가하며 컨테이너를 함께 연결합니다.">시작하기 튜토리얼</a>
및 <a href="container_ov.html#container_docker_ov" title="IBM Bluemix Container Service는 Docker 기술을 활용하는 Bluemix 런타임입니다. 기존 Docker 사용자와 Docker를 처음 사용하는 사용자들은 IBM Bluemix Container Service에서 다음 기능을 기대할 수 있습니다.">Docker와 IBM Containers</a> 간의 차이점을 확인하십시오. </div>
</div>
<p>Docker Compose에 대한 더 자세한 정보는
<a href="container_single_ui.html#container_compose_faq" title="Docker Compose에 대해 다음의 자주 묻는 질문을 검토합니다.">Docker Compose FAQ</a> 및 <a href="container_cli_reference_cfic.html#container_cli_reference_docker-compose" title="이러한 명령을 참조하여 IBM Bluemix Container Service 플러그인(bx ic)을 사용하여 다중 컨테이너 배치를 실행하고 관리합니다.">Docker Compose 명령 참조</a>를 검토하십시오. </p>
</section>
<section class="section timeRequired tutorialTimeRequired" role="region" aria-labelledby="d75728e3982"><h3 class="sectiontitle" id="d75728e3982">소요 시간</h3>45분</section>
<section role="region" aria-labelledby="d75728e3986" class="section section prerequisites"><h3 class="sectiontitle" id="d75728e3986">전제조건</h3>
컴퓨터에 Docker Compose 소프트웨어 패키지를 <a href="container_cli_cfic_install.html#container_cli_compose_install" title="한 번에 여러 단일 컨테이너를 시작하고 중지하기 위해 Docker Compose CLI를 설치할 수 있습니다.">설치</a>하거나 최신 버전으로 <a href="container_cli_cfic_install.html#container_cli_compose_upgrade" title="최신 기능을 사용하도록 Docker Compose 패키지의 버전을 업그레이드해야 합니다.">업그레이드</a>하십시오. </section></div>
<article class="topic task tutorialLesson nested2" role="article" aria-labelledby="d75728e4000" lang="ko-kr" id="container_compose_config"><h3 class="topictitle3" id="d75728e4000">학습 1: 다중 컨테이너 배치 구성</h3>
<div class="body taskbody"><p class="shortdesc">먼저, <span class="ph filepath">docker-compose.yml</span>이라는 YAML 파일에서 다중 컨테이너
배치의 각 서비스를 구성합니다. 각 서비스에 대해 이미지, 노출할 포트 및 시스템의 다른 서비스에 대한 링크를 지정합니다. </p>
<div class="section prereq">시작하기 전에 다음과 같은 단계를 고려하십시오. <ul><li><samp class="ph codeph"><span class="ph"><samp class="ph codeph">bx ic</samp></span> namespace-get</samp>을 실행하여
네임스페이스 정보를 검색하고 이름이 <var class="keyword varname">$your_namespace</var>인 환경 변수에 이 정보를 저장하십시오.
<pre class="codeblock"><code><var class="keyword varname">$your_namespace</var>=&lt;my_namespace_information&gt;</code></pre>
</li>
<li>개인용 <span class="keyword">Bluemix</span> 이미지 레지스트리에서 <a href="container_single_ui.html#container_gettingstarted_tutorial_lesson_2" title="이 학습에서는 두 가지 방법(Docker Hub에서 이미지 복사, Dockerfile 작성)을 사용하여 개인용 레지스트리에 이미지를 추가합니다. 사용자 고유의 Dockerfile을 작성하면 사용자 고유의 명령을 이미지에 추가할 수 있습니다. 따라서 그 이미지에서 실행된 모든 컨테이너에 해당 명령이 포함됩니다. 컨테이너의 이점 중 하나는 이러한 이미지가 조직의 모든 사람들이 지속적 운영 환경으로 컨테이너를 빌드할 수 있도록 소스 제어를 유지보수하는 데 도움이 된다는 점입니다.">Lets-Chat 및 MongoDB 컨테이너 이미지</a>를 빌드하십시오. </li>
</ul>
</div><ol class="steps"><li class="step stepexpand"><span class="cmd">Docker Compose 구성 파일을 저장할 수 있는 사용자의 컴퓨터에 이름이 <var class="keyword varname">composetutorial</var>인 Docker Compose 프로젝트
디렉토리를 작성하고 이 디렉토리로 이동하십시오. </span> Docker Compose 명령 실행 시 사용자가 이 디렉토리에 있어야 구성 파일을 찾을 수 있습니다. 그렇지 않으면 Docker Daemon으로부터 오류 메시지가 수신됩니다. 런타임 시에 모든 파일이 Docker Daemon에 전송되었으므로 배치 시간을 줄이려면
서브디렉토리가 포함된 디렉토리를 선택하지 마십시오. <pre class="codeblock"><code>mkdir <var class="keyword varname">composetutorial</var> &amp;&amp; cd <var class="keyword varname">composetutorial</var></code></pre>
</li>
<li class="step stepexpand"><span class="cmd"><span class="ph filepath">docker-compose.yml</span> 파일을 작성하십시오. </span> 컴퓨터에서 선호하는 CLI 편집기 또는 문서 편집기를 사용하여 구성 파일을 작성할 수 있습니다.
다음 예에서는 <a href="http://www.nano-editor.org/dist/v2.2/nano.html" rel="external" target="_blank" title="(새로운 탭이나 창으로 열기)">nano 편집기</a>를 사용하여
<span class="ph filepath">docker-compose.yml</span>파일을 작성하는 방법을 보여줍니다.
<ol type="a"><li>nano 편집기를 열고 파일 이름으로 <span class="ph filepath">docker-compose.yml</span>을 입력하십시오. <pre class="codeblock"><code>nano <span class="ph filepath">docker-compose.yml</span></code></pre>
</li>
<li>Lets-Chat 앱을 실행하는 다중 컨테이너 배치에 대한 서비스를 정의하십시오. <var class="keyword varname">#</var>를 사용하여 주석을 입력할 수 있습니다.
<pre class="codeblock"><code>#Name of your Lets-Chat service. 
#The first container that is started for this service is named:
#<span class="ph filepath">composetutorial_lets-chat_1</span>
lets-chat: 
  #Container image that is used to run the lets-chat service.   #Use the full path to your private Bluemix images registry.
  image: registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">$your_namespace</var>/lets-chat  
  #Enter a public IP address and port 8080. Run <samp class="ph codeph"><span class="ph"><samp class="ph codeph">bx ic</samp></span> ips</samp>
  #to list available public IP addresses in your space. 
  #Option 1: If you do not have a public IP address 
  #that you can use, you can request a new one as follows: 
  #ports:
  #- "request:8080:8080". 
  #Option 2: If you want to bind a public IP address after your Lets-Chat container
  #is created by using the <samp class="ph codeph"><span class="ph"><samp class="ph codeph">bx ic</samp></span> ip-bind</samp> command, enter the following:
  #ports:
  #- "8080"
  #Option 3: Bind a public IP address directly to your Lets-Chat container
  #ports:
  #- "<var class="keyword varname">YOUR_PUBLIC_IP_ADDRESS</var>:8080:8080"
  #Choose one of the port options described. 
  ports:
   - "<var class="keyword varname">SELECT_YOUR_PORT_OPTION</var>"
  #lets-chat service is linked to the mongo service. 
  links: 
    - mongo
#Name of your Mongo database service. 
#The first container that is started for this service is named:
#<span class="ph filepath">composetutorial_mongo_1</span>
mongo:
  #Container image that is used to run the mongo service.   #Use the full path to your private Bluemix images registry.
  image: registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">$your_namespace</var>/mongo
  #Container port 27017 is published within your private container network.   #If a container instance wants to send messages to a mongo container, 
  #requests need to be sent to this port. 
  expose:
    - "27017"</code></pre>
<div class="note tip"><span class="tiptitle">팁:</span>  자체 <span class="ph filepath">docker-compose.yml</span> 파일을 작성할 때 <samp class="ph codeph">docker-compose up</samp>
명령이 구성 파일에서 컨테이너를 빌드할 수 있도록 하나 이상의 서비스 이름과 사용할 컨테이너 이미지에 대한 링크를 추가하십시오.</div>
<div class="steps note"><span class="notetitle">참고:</span> <span class="keyword">IBM
Bluemix Container Service</span>에서는
<span class="ph filepath">docker-compose.yml</span> 파일 형식의 버전 1만 지원합니다. 버전 2는 현재 지원되지 않습니다. 
<span class="ph filepath">docker-compose.yml</span> 파일의 작성 방법에 대한 예를 추가로 알아보려면
<a href="https://docs.docker.com/compose/compose-file/compose-file-v1/" rel="external" target="_blank" title="(새로운 탭이나 창으로 열기)">Docker compose
file version 1 reference</a>를 참조하십시오. </div>
</li>
<li><span class="ph uicontrol">Ctrl+O</span>를 눌러 변경사항을 저장하십시오. <span class="ph uicontrol">ENTER</span>를 눌러 변경사항을 확인하십시오. </li>
<li><span class="ph uicontrol">Ctrl+X</span>를 눌러 nano 편집기를 종료하십시오. </li>
</ol>
</li>
</ol>
<div class="section result">축하합니다. 이제 <span class="keyword">IBM
Bluemix Container Service</span>와 Docker Compose를 사용하여
<a href="container_single_ui.html#container_compose_run" title="다음으로 다중 컨테이너 배치를 배치하고 실행합니다. Lets-Chat 및 Mongo 데이터베이스 컨테이너를 개별적으로 작성해서 시작하고 수동으로 함께 링크하는 대신에 docker-compose.yml 파일의 서비스 정의를 기반으로 사용자의 컨테이너를 작성하는 단일 Docker Compose 명령을 사용합니다.">Lets-Chat 앱을 실행하는 다중 컨테이너 배치를 배치</a>할 준비가 되었습니다. </div></div>
</article><article class="topic task tutorialLesson nested2" role="article" aria-labelledby="d75728e4225" lang="ko-kr" id="container_compose_run"><h3 class="topictitle3" id="d75728e4225">학습 2: 다중 컨테이너 배치 실행</h3>
<div class="body taskbody"><p class="shortdesc">다음으로 다중 컨테이너 배치를 배치하고 실행합니다. Lets-Chat 및 Mongo 데이터베이스 컨테이너를 개별적으로 작성해서
시작하고 수동으로 함께 링크하는 대신에 <span class="ph filepath">docker-compose.yml</span> 파일의 서비스 정의를 기반으로
사용자의 컨테이너를 작성하는 단일 Docker Compose 명령을 사용합니다. </p>
<ol class="steps"><li class="step stepexpand"><span class="cmd">아직 이를 수행하지 않은 경우에는 <a href="container_cli_cfic_install.html#container_cli_login__option2_li">IBM Containers 플러그인에 로그인</a>하고 기본 Docker 명령을 실행하도록 CLI를 구성하십시오. </span></li>
<li class="step stepexpand"><span class="cmd"><span class="ph filepath">docker-compose.yml</span> 파일이 있는 디렉토리로 이동하십시오. </span> Docker Compose 명령을 실행하려면 사용자가 <span class="ph filepath">docker-compose.yml</span> 파일이 저장된 디렉토리에 있어야 합니다. </li>
<li class="step stepexpand"><span class="cmd"><span class="ph filepath">docker-compose.yml</span> 파일의 서비스 정의를 기반으로 다중 컨테이너
배치를 배치하고 실행하십시오. </span> <span class="keyword">IBM
Bluemix Container Service</span>에서 대부분의 서비스와 앱은
장기 실행 태스크입니다. 그러므로 분리하기 위한 방법 없이 컨테이너의 콘솔 출력에 멈춰 있지 않도록 하려면 <samp class="ph codeph">-d</samp> 옵션을 사용하십시오. <pre class="codeblock"><code>docker-compose up -d</code></pre>
 <samp class="ph codeph">-d</samp> 옵션을 사용하는 경우,
컨테이너 인스턴스가 작성된 후에 그 이름이 CLI에 표시되기 때문에 해당 컨테이너 인스턴스를 계속 추적할 수 있습니다.

<pre class="codeblock"><code>$ docker-compose up -d

Creating composetutorial_mongo_1
Creating composetutorial_lets-chat_1</code></pre>
</li>
<li class="step stepexpand"><span class="cmd">다중 컨테이너 배치의 컨테이너가 실행 중인지 확인하십시오. </span> <pre class="codeblock"><code>docker-compose ps</code></pre>
컨테이너 인스턴스가 실행 중이면 <span class="ph uicontrol">작동 중</span> 상태가 표시됩니다. 이 프로세스는 몇 분 정도 소요됩니다. 출력은
다음과 같이 표시됩니다.

<pre class="codeblock"><code>$ docker-compose ps

        Name                   Command      State             Ports             
-----------------------------------------------------------------------
composetutorial_lets-chat_1                  Up      192.0.2.100:8080-&gt;8080/tcp
composetutorial_mongo_1                    Up      203.0.113.23:27017-&gt;27017/tcp</code></pre>
</li>
<li class="step stepexpand">옵션: <span class="cmd"><span class="ph filepath">docker-compose.yml</span> 파일에 IP 주소를 구성하지 않은 경우,
사용 가능한 공인 IP 주소를 Lets-Chat 컨테이너에 바인드하십시오. </span> <samp class="ph codeph"><span class="ph"><samp class="ph codeph">bx ic</samp></span> ips</samp>를 실행하여
사용자의 영역에 사용 가능한 공인 IP 주소를 나열하거나 <samp class="ph codeph"><span class="ph"><samp class="ph codeph">bx ic</samp></span> ip-request</samp>를 실행하여
새 공인 IP 주소를 요청하십시오. <var class="keyword varname">&lt;IP_address&gt;</var>를 공인 IP 주소로 대체하십시오. <pre class="codeblock"><code><span class="ph"><samp class="ph codeph">bx ic</samp></span> ip-bind <var class="keyword varname">&lt;IP_address&gt;</var> composetutorial_lets-chat_1</code></pre>
</li>
<li class="step stepexpand">옵션: <span class="cmd">컨테이너에 대한 IP 주소의 바인딩이 완료하는 것을 기다리십시오. </span> 이 프로세스는 몇 분 정도 소요됩니다. 완료되면 <span class="ph uicontrol">확인</span> 메시지가 CLI에 표시됩니다. </li>
<li class="step stepexpand"><span class="cmd">인터넷에서 Lets-Chat 앱에 액세스하십시오. </span> <ol type="a" class="ol substeps"><li class="li substep substepexpand"><span class="cmd">웹 브라우저를 여십시오.</span></li>
<li class="li substep substepexpand"><span class="cmd">예 <samp class="ph codeph">192.0.2.100:8080</samp>에 표시된 것처럼 웹 브라우저에 공인 IP 주소와 공용 Lets-Chat 포트 8080을 입력하십시오. </span> 웹 브라우저에 Lets-Chat 로그인 페이지가 표시됩니다. <p><img src="images/lets-chat_screenshot.jpg" alt="Let's Chat 웹 앱에 로그인하십시오."></p>
</li>
</ol>
</li>
</ol>
<div class="section result">완료되었습니다. 이제 Lets-Chat 앱을 사용할 수 있도록 준비가 되었습니다. Lets-Chat 계정을 자유롭게 작성하고
앱의 기능을 살펴보십시오. Lets-Chat 앱을 더욱 안정적으로 만들려면 <a href="container_single_ui.html#container_compose_scale" title="다중 컨테이너 배치가 현재 실행 중인 상태로 Lets-Chat 컨테이너 인스턴스의 수를 늘려 앱을 보다 안정적으로 만듭니다.">Lets-Chat 컨테이너 인스턴스 확장</a>을 수행하십시오. </div></div>
</article><article class="topic task tutorialLesson nested2" role="article" aria-labelledby="d75728e4399" lang="ko-kr" id="container_compose_scale"><h3 class="topictitle3" id="d75728e4399">학습 3: 다중 컨테이너 배치 스케일링</h3>
<div class="body taskbody"><p class="shortdesc">다중 컨테이너 배치가 현재 실행 중인 상태로 Lets-Chat 컨테이너 인스턴스의 수를
늘려 앱을 보다 안정적으로 만듭니다. </p>
<div class="section context"></div><ol class="steps"><li class="step stepexpand"><span class="cmd"><span class="ph filepath">docker-compose.yml</span> 파일을 업데이트하십시오. </span> 이 서비스에 대해 시작된 모든 컨테이너 인스턴스가 동일한 포트를 사용하려고 시도하게 되므로
공용 포트를 노출하지 않는 서비스만 스케일링할 수 있습니다. 이전 학습에서 Lets-Chat 서비스에 대해 포트 8080이 공개적으로 노출되도록 정의했기 때문에 <span class="ph filepath">docker-compose.yml</span>
파일에서 이 설정을 변경해야 합니다. <ol type="a" class="ol substeps"><li class="li substep substepexpand"><span class="cmd"><span class="ph filepath">docker-compose.yml</span>을 여십시오. </span> <pre class="codeblock"><code>nano <span class="ph filepath">docker-compose.yml</span></code></pre>
</li>
<li class="li substep substepexpand"><span class="cmd"><span class="ph uicontrol">ports</span> 매개변수를 Lets-Chat 서비스 정의에서 <span class="ph uicontrol">expose</span>로 대체하고 공인 IP 주소를 삭제하십시오. </span> expose 매개변수는 사설 컨테이너 네트워크 내에서만 포트를 공개합니다. 
Lets-Chat 서비스 정의의 내용은 다음과 같습니다.

<pre class="codeblock"><code>lets-chat: 
  image: registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">$your_namespace</var>/lets-chat 
  expose:
   - "8080"
  links: 
    - mongo</code></pre>
</li>
<li class="li substep substepexpand"><span class="cmd"><span class="ph uicontrol">Ctrl+O</span>를 눌러 변경사항을 저장하십시오. <span class="ph uicontrol">ENTER</span>를 눌러 변경사항을 확인하십시오. </span></li>
<li class="li substep substepexpand"><span class="cmd"><span class="ph uicontrol">Ctrl+X</span>를 눌러 nano 편집기를 종료하십시오. </span></li>
</ol>
</li>
<li class="step stepexpand"><span class="cmd">다중 컨테이너 배치를 다시 작성하십시오. <samp class="ph codeph">--force-recreate</samp> 옵션을 사용하여
배치에 모든 인스턴스를 다시 작성하십시오. </span> <pre class="codeblock"><code>docker-compose up -d --force-recreate</code></pre>
</li>
<li class="step stepexpand"><span class="cmd">Lets-Chat 서비스를 2개의 컨테이너 인스턴스로 스케일을 확장하십시오. </span> 다음 명령으로 <span class="keyword">IBM
Bluemix Container Service</span>는 <span class="ph filepath">docker-compose.yml</span> 파일의 서비스 정의를 기반으로 새 Lets-Chat
컨테이너 인스턴스를 자동으로 작성합니다. <div class="steps note"><span class="notetitle">참고:</span> 컨테이너 인스턴스 수를 줄이면
<span class="keyword">IBM
Bluemix Container Service</span>가 자동으로 중지되고
다중 컨테이너 배치에서 추가 컨테이너 인스턴스를 제거합니다. </div>

<pre class="codeblock"><code>docker-compose scale lets-chat=2</code></pre>
CLI 출력은 다음과 같이 표시됩니다.

<pre class="codeblock"><code>$ docker-compose scale lets-chat=2

Creating and starting composetutorial_lets-chat_2 ... done</code></pre>
</li>
<li class="step stepexpand"><span class="cmd">다중 컨테이너 배치를 다시 작성하여 새 컨테이너 인스턴스를 연결하십시오. </span> Docker Compose에서는 현재 자동 링크 연결/분리를 지원하지 않으므로
<samp class="ph codeph">--force-recreate</samp> 옵션을 사용하여 다중 컨테이너 배치의 모든 컨테이너
인스턴스를 다시 작성해야 합니다. <pre class="codeblock"><code>docker-compose up -d --force-recreate</code></pre>
</li>
<li class="step stepexpand"><span class="cmd">Mongo 컨테이너 인스턴스가 Lets-Chat 컨테이너 인스턴스에 링크되었는지 확인하십시오. </span> <pre class="codeblock"><code>docker inspect composetutorial_lets-chat_1</code></pre>

<pre class="codeblock"><code>docker inspect composetutorial_lets-chat_2</code></pre>
각 응답의 <var class="keyword varname">HostConfig &gt; Links</var> 섹션에서 링크된 Mongo 컨테이너 인스턴스를 검토할 수 있습니다.
<pre class="codeblock"><code>...
"HostConfig": {
        "Binds": [],
        "CapAdd": [],
        "CapDrop": [],
        "ContainerIDFile": "",
        "Links": [
            "composetutorial_mongo_1:mongo",
            "composetutorial_mongo_1:composetutorial_mongo_1",
            "composetutorial_mongo_1:composetutorial_mongo_1"
        ],
        "LogConfig": {
            "Config": {},
            "Type": "json-file"
        },
        "LxcConf": [],
        "PortBindings": {
            "8080/tcp": [
                {
                    "HostPort": "8080"
                }
            ]
        },
        "Privileged": false,
        "PublishAllPorts": false
    },
...</code></pre>
</li>
</ol>
<div class="section result">완료되었습니다. Lets-Chat 서비스의 스케일을 확장했으며 앱이 더욱 안정적이 되었습니다. 많은
사용자 트래픽에 대응하려면 다중 컨테이너 배치에 <a href="container_single_ui.html#container_compose_loadbalance" title="높은 워크로드에 대응하기 위해 Lets-Chat 컨테이너 인스턴스 간 수신 사용자 트래픽의 밸런스를 조절하는 다중 컨테이너 배치에 nginx 로드 밸런서를 추가합니다.">nginx 로드 밸런서를
추가</a>하여 Lets-Chat 컨테이너 인스턴스 간 워크로드의
밸런스를 조절하십시오. </div></div>
</article><article class="topic task tutorialLesson nested2" role="article" aria-labelledby="d75728e4584" lang="ko-kr" id="container_compose_loadbalance"><h3 class="topictitle3" id="d75728e4584">학습 4: 다중 컨테이너 배치에 로드 밸런서 추가</h3>
<div class="body taskbody"><p class="shortdesc">높은 워크로드에 대응하기 위해 Lets-Chat 컨테이너 인스턴스 간 수신 사용자 트래픽의
밸런스를 조절하는 다중 컨테이너 배치에 nginx 로드 밸런서를 추가합니다. </p>
<ol class="steps"><li class="step stepexpand"><span class="cmd"><span class="ph uicontrol">nginx</span> 로드 밸런서를 구성하십시오.</span> <ol type="a" class="ol substeps"><li class="li substep substepexpand"><span class="cmd"><span class="ph filepath">nginx.conf</span> 구성 파일을 작성하십시오.</span> <pre class="codeblock"><code>nano <span class="ph filepath">nginx.conf</span></code></pre>
</li>
<li class="li substep substepexpand"><span class="cmd">다음 정보를 구성 파일에 복사하십시오. </span> Lets-Chat 컨테이너 인스턴스 간의 워크로드의 밸런스를 조절하려면 이 모두를 구성 파일에서 업스트림 서버로서 추가해야 합니다. 이런 방식으로 모든 수신 요청이 Lets-Chat 컨테이너 중 하나로 전달됩니다.

<pre class="codeblock"><code>worker_processes 3;

events { worker_connections 1024; }

http {

        upstream lets-chat-app {
              ip_hash;
              server composetutorial_lets-chat_1:8080 weight=10 max_fails=3 fail_timeout=30s;
              server composetutorial_lets-chat_2:8080 weight=10 max_fails=3 fail_timeout=30s;
        }
         
        server {
              listen 80;
         
              location / {
                proxy_pass http://lets-chat-app;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host $host;
                proxy_cache_bypass $http_upgrade;
              }
        }
}</code></pre>
</li>
<li class="li substep substepexpand"><span class="cmd"><span class="ph uicontrol">Ctrl+O</span>를 눌러 변경사항을 저장하십시오. <span class="ph uicontrol">ENTER</span>를 눌러 변경사항을 확인하십시오. </span></li>
<li class="li substep substepexpand"><span class="cmd"><span class="ph uicontrol">Ctrl+X</span>를 눌러 nano 편집기를 종료하십시오. </span></li>
</ol>
</li>
<li class="step stepexpand"><span class="cmd"><span class="ph uicontrol">nginx</span> 이미지를 개인용 <span class="keyword">Bluemix</span> 이미지 레지스트리에 작성하십시오. </span> <ol type="a" class="ol substeps"><li class="li substep substepexpand"><span class="cmd">Dockerfile을 작성하십시오.</span> <pre class="codeblock"><code>nano Dockerfile</code></pre>
</li>
<li class="li substep substepexpand"><span class="cmd">다음 정보를 Dockerfile에 복사하십시오. </span> 작성하는 이미지는 Dockerhub에서 제공하는 공용 <span class="ph uicontrol">nginx</span> 이미지를 기반으로 합니다. 이전 단계에서 지정한 사용자 정의 설정을 적용하려면 <samp class="ph codeph">COPY</samp> 명령을 사용하여
<span class="ph filepath">nginx.conf</span> 파일을 <span class="ph uicontrol">nginx</span> 구성 파일 위치에 복사하십시오.
<pre class="codeblock"><code>#Uses the public nginx image available on Dockerhub.
FROM nginx
#Copies your custom <span class="ph filepath">nginx.conf</span> file into the nginx configuration file location.
COPY nginx.conf /etc/nginx/nginx.conf</code></pre>
</li>
<li class="li substep substepexpand"><span class="cmd"><span class="ph uicontrol">Ctrl+O</span>를 눌러 변경사항을 저장하십시오. <span class="ph uicontrol">ENTER</span>를 눌러 변경사항을 확인하십시오. </span></li>
<li class="li substep substepexpand"><span class="cmd"><span class="ph uicontrol">Ctrl+X</span>를 눌러 nano 편집기를 종료하십시오. </span></li>
<li class="li substep substepexpand"><span class="cmd"><span class="ph uicontrol">nginx</span> 이미지를 빌드하여 개인용 <span class="keyword">Bluemix</span> 이미지 레지스트리에 푸시하십시오. </span> <pre class="codeblock"><code>docker build -t registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">$your_namespace</var>/nginx .</code></pre>

CLI 출력은 다음과 같이 표시됩니다.

<pre class="codeblock"><code>Sending build context to Docker daemon 9.728 kB
Step 1 : FROM nginx
 ---&gt; 6f62f48c4e55
Step 2 : COPY nginx.conf /etc/nginx/nginx.conf
 ---&gt; bc40817f0593
Removing intermediate container 64c5e180943f
Successfully built bc40817f0593
The push refers to a repository [registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">$your_namespace</var>/nginx] (len: 1)
bc40817f0593: Pushed 
6f62f48c4e55: Pushed 
50ed65ac2e2d: Pushed 
fed44c33bce9: Pushed 
73e8d4f6bf84: Pushed 
latest: digest: sha256:99587168cbf699b32804c4ff0de610460dfa150120b12385b194c2f9236903f5 size: 15270</code></pre>
</li>
</ol>
</li>
<li class="step stepexpand"><span class="cmd"><span class="ph uicontrol">nginx</span> 서비스 정의를 <span class="ph filepath">docker-compose.yml</span> 파일에 추가하십시오. </span> <ol type="a" class="ol substeps"><li class="li substep substepexpand"><span class="cmd"><span class="ph filepath">docker-compose.yml</span> 파일을 여십시오. </span> <pre class="codeblock"><code>nano <span class="ph filepath">docker-compose.yml</span></code></pre>
</li>
<li class="li substep substepexpand"><span class="cmd">다음 정보를 <span class="ph filepath">docker-compose.yml</span>에 복사하십시오. <span class="ph uicontrol">nginx</span> 로드 밸런서에 액세스하려면 사용하고자 하는 공인 IP 주소로 <var class="keyword varname">IP_ADDRESS</var>를 대체하십시오. </span> <pre class="codeblock"><code>nginx:
  image: registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">$your_namespace</var>/nginx  
  ports:
   - "<var class="keyword varname">IP_ADDRESS</var>:80:80"
  links: 
    - lets-chat</code></pre>
<span class="ph filepath">docker-compose.yml</span> 파일은 다음과 같이 표시됩니다.

<pre class="codeblock"><code>nginx:
  image: registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">$your_namespace</var>/nginx
  ports:
   - "<var class="keyword varname">IP_ADDRESS</var>:80:80"
  links: 
    - lets-chat
lets-chat: 
  image: registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">$your_namespace</var>/lets-chat
  expose:
   - "8080"
  links: 
    - mongo
mongo:
  image: registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">$your_namespace</var>/mongo
  expose:
    - "27017"</code></pre>
</li>
<li class="li substep substepexpand"><span class="cmd"><span class="ph uicontrol">Ctrl+O</span>를 눌러 변경사항을 저장하십시오. <span class="ph uicontrol">ENTER</span>를 눌러 변경사항을 확인하십시오. </span></li>
<li class="li substep substepexpand"><span class="cmd"><span class="ph uicontrol">Ctrl+X</span>를 눌러 nano 편집기를 종료하십시오. </span></li>
</ol>
</li>
<li class="step stepexpand"><span class="cmd"><span class="ph uicontrol">nginx</span> 로드 밸런서를 사용하여 Lets-Chat 앱을 실행하는
다중 컨테이너 배치를 배치하십시오. </span> <ol type="a" class="ol substeps"><li class="li substep substepexpand"><span class="cmd">다중 컨테이너 배치를 다시 작성하십시오. </span> 링크가 올바르게 연결될 수 있도록 <samp class="ph codeph">--force-recreate</samp>
옵션을 사용하여 다중 컨테이너 배치의 모든 컨테이너 인스턴스를 다시 작성하십시오.
<pre class="codeblock"><code>docker-compose up -d --force-recreate</code></pre>
</li>
<li class="li substep substepexpand"><span class="cmd">컨테이너가 올바르게 링크되어 있는지 확인하십시오. </span> <pre class="codeblock"><code>docker inspect composetutorial_nginx_1</code></pre>

응답의 <var class="keyword varname">HostConfig &gt; Links</var> 섹션에서 링크된 Lets-Chat 컨테이너 인스턴스를 검토할 수 있습니다.
<pre class="codeblock"><code>...
"HostConfig": {
        "Binds": [],
        "CapAdd": [],
        "CapDrop": [],
        "ContainerIDFile": "",
        "Links": [
            "composetutorial_lets-chat_2:composetutorial_lets-chat_2",
            "composetutorial_lets-chat_1:composetutorial_lets-chat_1",
            "composetutorial_lets-chat_1:composetutorial_lets-chat_1",
            "composetutorial_lets-chat_2:lets-chat",
            "composetutorial_lets-chat_2:composetutorial_lets-chat_2"
        ],
        "LogConfig": {
            "Config": {},
            "Type": "json-file"
        },
        "LxcConf": [],
        "PortBindings": {
            "80/tcp": [
                {
                    "HostPort": "80"
                }
            ]
        },
        "Privileged": false,
        "PublishAllPorts": false
    },
...</code></pre>
</li>
</ol>
</li>
<li class="step stepexpand"><span class="cmd">사용자 정의 <span class="ph filepath">nginx.config</span> 설정이 <span class="ph uicontrol">nginx</span> 컨테이너 인스턴스에 적용되는지 확인하십시오. </span> <ol type="a" class="ol substeps"><li class="li substep substepexpand"><span class="cmd"><span class="ph uicontrol">nginx</span> 컨테이너에 로그인하십시오. </span> <pre class="codeblock"><code>docker exec -it composetutorial_nginx_1 bash</code></pre>
</li>
<li class="li substep substepexpand"><span class="cmd">호스트 구성을 검토하십시오. </span> <pre class="codeblock"><code>cat <span class="ph filepath">/etc/hosts</span></code></pre>
사용자 정의 설정이 적용되면,
링크된 Lets-Chat 컨테이너 인스턴스가 CLI 출력에서 해당 사설 IP 주소와 함께 나열됩니다. <pre class="codeblock"><code>127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
198.51.100.19	composetutorial_lets-chat_1
198.51.100.18	composetutorial_lets-chat_2
198.51.100.20	instance-000f2b2b
198.51.100.18	lets-chat
198.51.100.20	composetutorial-nginx-1
198.51.100.19	composetutoral_lets-chat_1
198.51.100.18	composetutorial_lets-chat_2
198.51.100.20	instance-000f2b2b</code></pre>
</li>
<li class="li substep substepexpand"><span class="cmd">CLI에 <samp class="ph codeph">exit</samp>를 입력하여 컨테이너에서 로그아웃하십시오. </span></li>
</ol>
</li>
</ol>
<div class="section result">완료되었습니다. 이제 Lets-Chat 컨테이너 간 워크로드의 밸런스를 조절하고 더 높은 사용자 트래픽에 대응할 수 있습니다. 마지막 단계로
<a href="container_single_ui.html#container_compose_remove" title="최종 단계로서 다중 컨테이너 배치를 제거하여 사용된 리소스를 릴리스하고 할당량의 사용을 최대화합니다.">다중 컨테이너 배치
삭제</a>를 수행하여 사용된 리소스를 릴리스하고 할당량 사용을 최대화할 수 있습니다. </div></div>
</article><article class="topic task tutorialLesson nested2" role="article" aria-labelledby="d75728e4913" lang="ko-kr" id="container_compose_remove"><h3 class="topictitle3" id="d75728e4913">학습 5: 다중 컨테이너 배치 제거</h3>
<div class="body taskbody"><p class="shortdesc">최종 단계로서 다중 컨테이너 배치를 제거하여 사용된 리소스를 릴리스하고 할당량의 사용을 최대화합니다. </p>
<div class="section context"><div class="note attention"><span class="attentiontitle">주의:</span> 다중 컨테이너 배치 삭제는 실행 취소할 수 없습니다. 다중 컨테이너
배치의 구성을 유지하려면 <span class="ph filepath">docker-compose.yml</span> 파일을 제거하지 마십시오. </div>
</div><ol class="steps"><li class="step stepexpand"><span class="cmd">다중 컨테이너 배치에서 실행 중인 모든 컨테이너 인스턴스를 중지하십시오. </span> <pre class="codeblock"><code>docker-compose stop</code></pre>
</li>
<li class="step stepexpand"><span class="cmd">다중 컨테이너 배치에서 모든 컨테이너 인스턴스를 제거하십시오. </span> <pre class="codeblock"><code>docker-compose rm</code></pre>
 제거 프로세스를 수행하는 동안 모든 컨테이너 인스턴스를
제거할지 확인하도록 요청됩니다. <span class="ph uicontrol">y</span>를 입력하여 확인하십시오. </li>
<li class="step stepexpand">옵션: <span class="cmd">모든 컨테이너 인스턴스가 컨테이너 시스템에서 제거되는지 확인하십시오. </span> <pre class="codeblock"><code>docker-compose ps</code></pre>
</li>
<li class="step stepexpand">옵션: <span class="cmd"><span class="ph filepath">docker-compose.yml</span> 파일을 삭제하십시오. </span> <div class="note tip"><span class="tiptitle">팁:</span> 파일을 다시 사용하려는 경우에는 삭제하는 대신에 소스-제어 시스템에 저장하십시오. </div>


<pre class="codeblock"><code>rm <span class="ph filepath">docker-compose.yml</span></code></pre>
</li>
<li class="step stepexpand">옵션: <span class="cmd">Docker Compose 프로젝트 디렉토리를 삭제하십시오. </span> <pre class="codeblock"><code>cd &amp;&amp; rmdir composetutorial</code></pre>
</li>
</ol>
<div class="section result">다중 컨테이너 배치가 정상적으로 제거되었으며 할당량 사용을 최대화했습니다. </div></div>
</article><article class="topic concept nested2" role="article" aria-labelledby="d75728e5019" lang="ko-kr" id="container_compose_yml"><h3 class="topictitle3" id="d75728e5019"><span class="ph filepath">docker-compose.yml</span> 파일에서 지원되는 옵션</h3>
<div class="body conbody"><p class="shortdesc"></p>
<div><span class="keyword">IBM
Bluemix Container Service</span>에서
지원되는 <span class="ph filepath">docker-compose.yml</span> 파일 옵션을 검토하십시오. <ul><li><a href="container_single_ui.html#container_compose_yml__environment">environment</a></li>
<li><a href="container_single_ui.html#container_compose_yml__expose">expose</a></li>
<li><a href="container_single_ui.html#container_compose_yml__image">image</a></li>
<li><a href="container_single_ui.html#container_compose_yml__links">links</a></li>
<li><a href="container_single_ui.html#container_compose_yml__mem">mem_limit</a></li>
<li><a href="container_single_ui.html#container_compose_yml__ports">ports</a></li>
<li><a href="container_single_ui.html#container_compose_yml__volumes">volumes</a></li>
</ul>
</div><section role="region" aria-labelledby="d75728e5108" id="container_compose_yml__environment"><h4 class="sectiontitle" id="d75728e5108"><span class="ph"><samp class="ph codeph">environment</samp></span></h4>
<span class="ph uicontrol">environment</span> 매개변수를 사용하여 환경 변수를 설정하거나
<span class="keyword">Bluemix</span> 서비스 또는 앱을
Docker Compose 서비스에 바인드할 수 있습니다. <div class="steps note"><span class="notetitle">참고:</span>  <span class="keyword">Bluemix</span> 서비스를 다중 컨테이너 배치에 추가하려면
영역에 이 서비스의 인스턴스를 작성해야 합니다. 자세한 정보는
<a href="container_integrations.html#container_integrations_binding" title="IBM Bluemix에는 서비스 목록이 있으며 앱 개발자 대신 해당 서비스를 관리합니다. 사용할 컨테이너의 Bluemix 서비스를 추가하려면 이 서비스의 인스턴스를 요청하고 서비스를 컨테이너에 바인드해야 합니다.">Bluemix GUI에서 서비스 바인딩</a>의 내용을 참조하십시오.<p>일부 서비스는 컨테이너에 대한 서비스의 직접 바인딩을 지원하지 않습니다.
이 경우에는 Cloud Foundry 앱을 작성해야 합니다. 자세한 정보는
<a href="container_troubleshoot.html#ts_bridge_app">Bluemix 서비스가 컨테이너에 직접 바인드되지 않음</a>의 내용을 참조하십시오.</p>
</div>
<ul><li><span class="keyword option">Bluemix 서비스 바인드</span><p>서비스를 바인드하려면 <span class="ph uicontrol">CCS_BIND_SRV</span> 키를 사용하십시오. <var class="keyword varname">&lt;service_instance_name&gt;</var>을
개인용 <span class="keyword">Bluemix</span> 이미지 레지스트리에서 작성한 서비스 인스턴스의 이름으로
대체하십시오. </p>
<pre class="codeblock"><code>environment:
  - "CCS_BIND_SRV=<var class="keyword varname">&lt;service_instance_name&gt;</var>"</code></pre>
</li>
<li><span class="keyword option">Cloud Foundry 앱 바인드</span><p>앱을 바인드하려면 <span class="ph uicontrol">CCS_BIND_APP</span> 키를 사용하십시오. <var class="keyword varname">&lt;app_name&gt;</var>을
개인용 <span class="keyword">Bluemix</span> 이미지 레지스트리에서 작성한 Cloud Foundry 앱의 이름으로
대체하십시오. </p>
<pre class="codeblock"><code>environment:
  - "CCS_BIND_APP=<var class="keyword varname">&lt;app_name&gt;</var>"</code></pre>
</li>
</ul>
<dl><dt class="dlterm">예</dt>
<dd>다음 예에서는 lets-chat 서비스에 대해 이름이 <var class="keyword varname">containerbridge</var>인 Cloud Foundry 앱을 바인드하고
이름이 <var class="keyword varname">tmp_folder</var>인 환경 변수를 추가하는 <span class="ph filepath">docker-compose.yml</span> 파일을 보여줍니다. <pre class="codeblock"><code>#Name of your service
lets-chat: 
  #Container image that is used to run the lets-chat service. Replace <var class="keyword varname">&lt;my_namespace&gt;</var> with the name of your namespace.
  image: registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/lets-chat  
  #Use <span class="ph uicontrol">CCS_BIND_SRV</span> to bind a <span class="keyword">Bluemix</span> service or <span class="ph uicontrol">CCS_BIND_APP</span> to bind a Cloud Foundry app to your Docker Compose service. 
  environment:
   - "CCS_BIND_APP=containerbridge"
   - "tmp_folder=/tmp"</code></pre>
</dd>
</dl>
</section><section role="region" aria-labelledby="d75728e5227" id="container_compose_yml__expose"><h4 class="sectiontitle" id="d75728e5227"><span class="ph"><samp class="ph codeph">expose</samp></span></h4>사설 네트워크에만 포트를 노출합니다. 
이 포트는 모든 링크된 서비스에 대해 액세스가 가능합니다. <dl><dt class="dlterm">예</dt>
<dd>다음 예에서는 포트 8080을 내부 네트워크에만 노출하는 샘플 <span class="ph filepath">docker-compose.yml</span> 파일을 보여줍니다. 
링크된 mongo 컨테이너는 이 포트를 사용하여 요청을 lets-chat 컨테이너에 전송합니다.
<pre class="codeblock"><code>lets-chat: 
  #Container image that is used to run the lets-chat service. Replace <var class="keyword varname">&lt;my_namespace&gt;</var> with the name of your namespace.
  image: registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/lets-chat  
  #Make a port available to the private network only. 
  expose:
   - "8080"
  links: 
    - mongo
mongo:
  image: registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/mongo</code></pre>
</dd>
</dl>
</section><section role="region" aria-labelledby="d75728e5259" id="container_compose_yml__image"><h4 class="sectiontitle" id="d75728e5259"><span class="ph"><samp class="ph codeph">image</samp></span></h4>Docker Compose 서비스를 실행하기 위해 사용할 기본 이미지를 정의합니다. 
이미지는 <span class="ph filepath">docker-compose.yml</span> 파일에서 사용되기 전에 개인용
<span class="keyword">Bluemix</span> 레지스트리에서 사용 가능해야 합니다. <p>이미지를 정의하려면
registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/<var class="keyword varname">&lt;image&gt;</var>:<var class="keyword varname">&lt;tag&gt;</var> 형식으로
개인용 <span class="keyword">Bluemix</span> 레지스트리에 대한 전체 경로를 사용하십시오. </p>
<dl><dt class="dlterm">예</dt>
<dd>다음 예는 lets-chat 서비스에 대한 기본으로서 lets-chat 이미지를 정의하는
샘플 <span class="ph filepath">docker-compose.yml</span> 파일을 보여줍니다. <pre class="codeblock"><code>#Name of your service
lets-chat: 
  #Container image that is used to run the lets-chat service. Replace <var class="keyword varname">&lt;my_namespace&gt;</var> with the name of your namespace.
  image: registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/lets-chat  
  </code></pre>
</dd>
</dl>
</section><section role="region" aria-labelledby="d75728e5310" id="container_compose_yml__links"><h4 class="sectiontitle" id="d75728e5310"><span class="ph"><samp class="ph codeph">links</samp></span></h4>다른 서비스에 대해 시작된 모든 컨테이너에 컨테이너를 링크합니다. 
링크는 서비스 간의 종속성 및 이에 따른 순서를 판별하며, 여기서
컨테이너는 <samp class="ph codeph">docker-compose up</samp> 명령을 실행할 때 시작됩니다. 서비스를 링크하려면 서비스 이름을 입력하십시오. <dl><dt class="dlterm">예</dt>
<dd>다음 예는 lets-chat 서비스에 대해 시작된 모든 컨테이너에 nginx 컨테이너를 링크하는
샘플 <span class="ph filepath">docker-compose.yml</span> 파일을 보여줍니다.
<pre class="codeblock"><code>#Name of your service
nginx:
  #Container image that is used to run the nginx service. Replace <var class="keyword varname">&lt;my_namespace&gt;</var> with the name of your namespace.
  image: registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/nginx  
  #Enter the name of the service that you want to link. 
  links: 
    - lets-chat
lets-chat: 
  image: registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace</var>/lets-chat  </code></pre>
</dd>
</dl>
</section><section role="region" aria-labelledby="d75728e5345" id="container_compose_yml__mem"><h4 class="sectiontitle" id="d75728e5345"><span class="ph"><samp class="ph codeph">mem_limit</samp></span></h4>컨테이너 인스턴스의 크기를 설정합니다. 
컨테이너 크기는 런타임 중에 컨테이너가 컴퓨팅 호스트에서 가져오는 메모리 및 디스크 공간의 최대 양을 정의합니다.
컨테이너 크기가 지정되고 나면 값을 변경할 수 없습니다. <p><span class="keyword">IBM
Bluemix Container Service</span>에서 다음 크기 간에 선택하십시오. </p>
<ul data-hd-audience="yellow"><li>Pico(64MB 메모리, 4GB 디스크 공간)</li>
<li>Nano(128 MB 메모리, 8GB 디스크 공간)</li>
<li>Micro(256MB 메모리, 16GB 디스크 공간)</li>
<li>Tiny(512MB 메모리, 32GB 디스크 공간)</li>
<li>Small(1024MB 메모리, 64GB 디스크 공간)</li>
<li>Medium(2048MB 메모리, 128GB 디스크 공간)</li>
<li>Large(4096MB 메모리, 256GB 디스크 공간)</li>
<li>X-Large(8192MB 메모리, 512GB 디스크 공간)</li>
<li>2X-Large(16384MB 메모리, 1TB 디스크 공간)</li>
</ul>

원하는 크기를 단위 레이블 <samp class="ph codeph">'M'</samp> 없이 메가바이트 단위로 입력하십시오. 
크기를 지정하지 않으면 기본적으로 모든 컨테이너가 <span class="ph uicontrol">micro</span> 크기로 작성됩니다. <dl><dt class="dlterm">예</dt>
<dd>다음 예에서는 lets-chat 서비스의 컨테이너 크기를 512MB로 설정하는 샘플 <span class="ph filepath">docker-compose.yml</span> 파일을 보여줍니다. <pre class="codeblock"><code>#Name of your service
lets-chat: 
  #Container image that is used to run the lets-chat service. Replace <var class="keyword varname">&lt;my_namespace&gt;</var> with the name of your namespace.
  image: registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/lets-chat  
  #Enter the size you want in megabytes
  mem_limit: 512</code></pre>
</dd>
</dl>
</section><section role="region" aria-labelledby="d75728e5406" id="container_compose_yml__ports"><h4 class="sectiontitle" id="d75728e5406"><span class="ph"><samp class="ph codeph">ports</samp></span></h4>
<span class="ph uicontrol">ports</span> 옵션을 사용하면 서비스에 대해 시작된 모든 컨테이너에 대해 공용 포트를 노출할 수 있습니다. 
다음 구성 중 하나 간에 선택하십시오. <ul><li><span class="keyword option">공인 IP 주소 요청</span><div class="p">이 구성은 사용자 영역에 대한 새 공인 IP 주소를 요청하고
포트 8080을 공용으로 노출하며 요청된 IP 주소를 컨테이너에 바인드합니다. <div class="steps note"><span class="notetitle">참고:</span> 영역에 새 IP 주소를 할당하려면
충분한 공인 IP 주소 할당량이 있어야 합니다. </div>
</div>
<pre class="codeblock"><code>ports:
  - "request:8080:8080"</code></pre>
</li>
<li><span class="keyword option">공용 포트에 노출</span><p>이 구성에서 포트 8080은 공용으로 노출됩니다. 
IP 주소가 컨테이너에 바인드되지 않습니다. 앱을 인터넷에서 액세스할 수 있도록 하려면 컨테이너가 작성된 후에
<a href="container_single_ui.html#container_cli_ips" title="공인 IP 주소를 요청하고 Bluemix의 컨테이너에 바인드합니다.">공인 IP 주소를 바인드</a>하십시오. </p>
<pre class="codeblock"><code>ports:
  - "8080"</code></pre>
</li>
<li><span class="keyword option">기존 공인 IP 주소 바인드</span><div class="p">이 구성에서 포트 8080은 공용으로 노출되며
기존 공인 IP 주소는 작성된 이후에 자동으로 컨테이너에 바인드됩니다. <div class="steps note"><span class="notetitle">참고:</span> 사용하는 IP 주소는 사용자 영역에 할당되어 있어야 하며 사용 가능해야 합니다. IP 주소가 이미 컨테이너에 바인드되어 있으면
우선 <a href="container_single_ui.html#container_cli_ips_unbind" title="컨테이너에서 공인 IP 주소를 바인드 해제할 수 있지만, 다른 컨테이너에서 아직 해당 IP 주소를 사용할 수 있으며 사용자 조직의 공인 IP 할당량으로 계수됩니다.">이를 바인드 해제</a>해야 합니다. </div>
</div>
<pre class="codeblock"><code>ports:
  - "<var class="keyword varname">IP_ADDRESS</var>:8080:8080"</code></pre>
</li>
</ul>
</section><section role="region" aria-labelledby="d75728e5458" id="container_compose_yml__volumes"><h4 class="sectiontitle" id="d75728e5458"><span class="ph"><samp class="ph codeph">volumes</samp></span></h4>
<span class="ph uicontrol">volumes</span> 매개변수를 사용하여 기존 볼륨을 서비스에 추가할 수 있습니다. <div class="steps note"><span class="notetitle">참고:</span> <span class="ph filepath">docker-compose.yml</span> 파일의 서비스 정의에 추가하려면 우선 볼륨을 작성해야 합니다. 
자세한 정보는 <a href="container_volumes_ov.html#container_volumes_cli" title="볼륨은 앱이 작성하는 데이터 또는 앱이 실행해야 하는 파일의 지속적 스토리지 위치입니다. 명령행에서 컨테이너의 볼륨을 작성할 수 있습니다.">명령행(CLI)에서 볼륨 작성</a> 주제를 참조하십시오. 
컨테이너에 마운트하기 전에 볼륨에 데이터를 채우려면 <a href="container_volumes_ov.html#container_volumes_mount" title="볼륨을 작성한 후에는 볼륨을 컨테이너에 마운트하고 볼륨이 마운트된 컨테이너에서 액세스할 수 있는 파일을 추가할 수 있습니다.">명령행 인터페이스(CLI)를 사용하여 볼륨에 파일 추가</a>의 내용을 참조하십시오. </div>
<dl><dt class="dlterm">예</dt>
<dd>다음 예는 이름이 <var class="keyword varname">my_volume</var>인 외부 볼륨을
lets-chat 서비스에 추가하는 샘플 <span class="ph filepath">docker-compose.yml</span> 파일을 보여줍니다. 
볼륨은 읽기 및 쓰기 액세스 권한으로 <span class="ph filepath">/tmp/data</span> 폴더에 마운트됩니다.
<pre class="codeblock"><code>version: '2'
#Name of your service
lets-chat: 
  #container image that is used to run the lets-chat service. Replace &lt;my_namespace&gt; with the name of your namespace.
  image: registry.<span class="keyword" data-hd-keyref="DomainName">DomainName</span>/<var class="keyword varname">&lt;my_namespace&gt;</var>/lets-chat  
  #You need to first create your volume before you can add it 
  volumes:
   - <var class="keyword varname">my_volume</var>:<span class="ph filepath">/tmp/data</span>:rw
#declare volume as external
volumes:
  my_volume:
    external: true</code></pre>
</dd>
</dl>
</section></div>
</article><article class="topic concept nested2" role="article" aria-labelledby="d75728e5515" lang="ko-kr" id="container_compose_faq"><h3 class="topictitle3" id="d75728e5515">Docker Compose FAQ</h3>
<div class="body conbody"><p class="shortdesc">Docker Compose에 대해 다음의 자주 묻는 질문을 검토합니다.</p>
<div class="p"><dl><dt class="dlterm">내 Docker Compose 클라이언트가 IBM Containers 서비스를 가리키도록 하려면 어떻게 해야 합니까? </dt>
<dd><span class="keyword">IBM
Bluemix Container Service</span> CLI에 로그인하는 경우에는
기본 Docker 명령(<samp class="ph codeph">docker</samp>)을 사용할 수 있도록 환경 변수를 설정하거나
<span class="keyword">IBM
Bluemix Container Service</span>(<span class="ph"><samp class="ph codeph">bx ic</samp></span>) 명령을 실행하도록
선택할 수 있습니다. <span class="keyword">IBM
Bluemix Container Service</span>에 대해
Docker Compose 명령을 실행하려면, <span class="keyword">IBM
Bluemix Container Service</span>에 대해
기본 Docker 명령을 실행하도록 환경 변수를 설정해야 합니다. 자세한 정보는
<a href="container_cli_cfic_install.html#container_cli_login" title="CLI를 설치한 후 CLI를 사용하기 위해 로그인합니다.">IBM Bluemix Container Service CLI 플러그인(bx ic)에 로그인</a>의 내용을 참조하십시오.</dd>
<dt class="dlterm">Docker Compose에서 확장 가능한 컨테이너 그룹을 어떻게 사용합니까?</dt>
<dd>Docker Compose는 다중 컨테이너 인스턴스 간의 워크로드 밸런싱이 이미 포함되어 있는
<span class="keyword">IBM
Bluemix Container Service</span> 그룹 개념을 지원하지 않습니다. 
컨테이너 인스턴스 간의 워크로드 밸런싱을 원하는 경우에는
로드 밸런서를 실행하는 다른 컨테이너를 추가하고 이를 컨테이너 인스턴스에 링크해야 합니다. </dd>
<dt class="dlterm"><span class="keyword">IBM
Bluemix Container Service</span>에서
지원되는 <span class="ph filepath">docker-compose.yml</span> 파일 형식의 버전은 무엇입니까? </dt>
<dd><span class="keyword">IBM
Bluemix Container Service</span>에서는
<span class="ph filepath">docker-compose.yml</span> 파일 형식의 버전 1만 지원합니다. 버전 2는 현재 지원되지 않습니다. </dd>
<dt class="dlterm">접속 모드에서 Docker Compose 명령을 어떻게 실행합니까? </dt>
<dd>접속 모드에서 <samp class="ph codeph">docker-compose up</samp> 명령을 실행할 때 오류가 발생할 수 있습니다. Docker Compose는 현재
<span class="keyword">IBM
Bluemix Container Service</span>에서 분리 모드의 실행만 지원됩니다. 
<samp class="ph codeph">-d</samp> 옵션을 사용하면 분리할 방법이 없는 컨테이너의 콘솔 출력에서 멈춤을 피할 수 있습니다. </dd>
<dt class="dlterm">내 다중 컨테이너 배치에서 실행되는 각 컨테이너 인스턴스의 로그에 어떻게
액세스합니까?</dt>
<dd><samp class="ph codeph">docker-compose logs</samp> 명령은 현재 <span class="keyword">IBM
Bluemix Container Service</span>에서 지원되지 않습니다. </dd>
<dt class="dlterm"><span class="ph filepath">docker-compose.yml</span> 파일에서 지원되는 매개변수 옵션은 무엇입니까? </dt>
<dd>지원되는 매개변수 옵션의 목록을 검토하려면 <a href="container_single_ui.html#container_compose_yml">docker-compose.yml 파일에서 지원되는 옵션</a>의 내용을 참조하십시오. </dd>
</dl>
</div>
</div>
</article></article></article></div></main></body></html>